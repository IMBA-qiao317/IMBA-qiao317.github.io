<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>钢棍乔师傅的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学无止境...">
<meta property="og:type" content="website">
<meta property="og:title" content="钢棍乔师傅的个人博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="钢棍乔师傅的个人博客">
<meta property="og:description" content="学无止境...">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="钢棍乔师傅的个人博客">
<meta name="twitter:description" content="学无止境...">
  
    <link rel="alternate" href="/atom.xml" title="钢棍乔师傅的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">钢棍乔师傅的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Python开发与人工智能</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-数据结构——排序算法-Python语言实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/数据结构——排序算法-Python语言实现/" class="article-date">
  <time datetime="2019-07-25T01:22:53.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/数据结构——排序算法-Python语言实现/">数据结构——排序算法(Python语言实现)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>1.排序的定义：假设含有n个记录的序列为{r1,r2,……,rn}，其相应的关键字分别为{k1,k2,……,kn}，需确定 1，2，……，n的一种排列p1,p2,……,pn，使其相应的关键字满足kp1≤kp2≤……≤kpn（非递减或非递增）关系，即使得序列成为一个按关键字有序的序列{rp1,rp2,……,rpn}，这样的操作就称为排序。</p>
<p>2.常用术语：稳定与不稳定<br>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；<br>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p>
<p>3.常用术语：内排序与外排序<br>内排序：所有排序操作都在内存中完成；<br>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p>4.排序算法的性能三大影响因素<br>(1) 时间性能(时间复杂度):  一个算法执行所耗费的时间。<br>(2)辅助空间 (空间复杂度)：运行完一个程序所需内存的大小。<br>(3) 算法的复杂性 : 算法本身的复杂度，而不是指算法的时间复杂度</p>
<p>5.各种排序算法不同的时间复杂度<br><img src="https://img-blog.csdnimg.cn/20190718153534484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>6.不同排序算法的内存占用情况<br><img src="https://img-blog.csdnimg.cn/20190718153640658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="交换排序：冒泡排序"><a href="#交换排序：冒泡排序" class="headerlink" title="交换排序：冒泡排序"></a>交换排序：冒泡排序</h2><p>1.定义：冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>2.冒泡排序算法的运作如下：<br>(1).比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。<br>(2).对每一对相邻元素作同样的工作，从开始第一对到结尾最后一对，这步做完后，最后的元素会是最大的数。<br>(3)针对所有的元素重复以上的步骤，除了最后一个。<br>(4)持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br><img src="https://img-blog.csdnimg.cn/20190718155117609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>例：<br>原始数组：5 <em>2</em> 2 8 3<br>第一趟排序：<em>2</em> 2 5 3 8<br>第二趟排序：<em>2</em> 2 3 5 8<br>第三趟排序：<em>2</em> 2 3 5 8</p>
<p>3.冒泡排序的特点：<br>    最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，可以推断出就是<br>n‐1 次的比较，没有数据交换，时间复杂度为O(n)。</p>
<pre><code>最坏的情况，即待排序表是逆序的情况，此时需要比较1+2+3+4+......+(n-1)=n(n-1)/2次，</code></pre><p>即时间复杂度为O(n**2)。</p>
<pre><code>稳定性: 稳定</code></pre><h2 id="交换排序：快速排序"><a href="#交换排序：快速排序" class="headerlink" title="交换排序：快速排序"></a>交换排序：快速排序</h2><p>1.快速排序的基本思想：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则课分别对这两部分记录继续进行排序，以达到整个序列有序的目的。<br><img src="https://img-blog.csdnimg.cn/20190718155932945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>层数为O(logn)(即调用栈的高度为O(logn)),而每层需要的时间为O(n)。因此整个算法需要的时间为O(n) * O(logn) = O(nlogn)</p>
<p>代码实现部分：</p>
<pre><code>def quicksort(array):
if len(array) &lt; 2:
    return array #基线条件：为空或只包含一个元素的数组是有序的
else:
    pivot = array[0] #递归条件
    less = [i for i in array[1:] if i &lt;= pivot] #由所有小于基准值的元素组成的子数组
    greater = [i for i in array[1:] if i &gt; pivot] #由所有大与基准值的元素组成的子数组
    return quicksort(less) + [pivot] + quicksort(greater)</code></pre><p>print(quicksort([28,2,1,27,15,9]))</p>
<h2 id="插入排序：直接插入排序"><a href="#插入排序：直接插入排序" class="headerlink" title="插入排序：直接插入排序"></a>插入排序：直接插入排序</h2><p><strong>直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表。</strong></p>
<p>插入排序示意图：<img src="https://img-blog.csdnimg.cn/20190718164242726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>直接插入排序代码实现：</p>
<pre><code>def insert_sort(nums):
    count = len(nums)
    for i in range(1, count):
        key = nums[i]
        j = i - 1
        while j &gt;= 0:
            if nums[j] &gt; key:
                nums[j + 1] = nums[j]
                nums[j] = key
            j -= 1
    return nums


if __name__ == &apos;__main__&apos;:
    nums = [3,2,7,5,1,9,6,8,0]
    sort_nums = insert_sort(nums)
    print(sort_nums)</code></pre><p>直接插入排序原理：每次将排序中的元素，插入到前面已经排好序的有序序列中去，直到排序完成。</p>
<p>步骤：<br>第一步，a[0]为有序区，待排序区为a[1..n-1]。令i=1。<br>第二步，将a[1]与a[0]中元素比较，将小的元素放在第一个位置。<br>第三步，以此类推，直到待排序中全部元素插入完成为止。</p>
<p>最好的情况,也就是要排序的表本身就是有序的, 因此没有移动的记录,时间复杂<br>度为 O(n)。 </p>
<p>最坏的情况,即待排序表是逆序的情况,时间复杂度为 O(n**2)。 </p>
<h2 id="直接插入排序：希尔排序"><a href="#直接插入排序：希尔排序" class="headerlink" title="直接插入排序：希尔排序"></a>直接插入排序：希尔排序</h2><p>希尔排序是D.L.Shell于 1959 年提出来的一种排序算法，在这之前排序算法的时间复杂度基本<br>都是O(n2)的，希尔排序算法是突破这个时间复杂度的第一批算法之一。</p>
<p>希尔排序基本思想：<br>算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的然后<br>再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行<br>直接插入排序后，排序完成。</p>
<p><img src="https://img-blog.csdnimg.cn/20190718165625651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019071816583495.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190718165922558.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190718165932403.png" alt="在这里插入图片描述"></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>定义：选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小(大)元素,存放到排序序列的起始位置,然后,再从剩余未排序元素中继续寻找最小(大)元素,然后放到已排序序列的末尾。以此类推,直到所有元素均排序完毕。</p>
<p><img src="https://img-blog.csdnimg.cn/20190718173113567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/数据结构——排序算法-Python语言实现/" data-id="cjyigf8w9000bpb5eseyvhoy0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-贪心算法与动态规划-Python语言实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/贪心算法与动态规划-Python语言实现/" class="article-date">
  <time datetime="2019-07-25T01:21:22.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/贪心算法与动态规划-Python语言实现/">贪心算法与动态规划(Python语言实现)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>定义：<br>在对问题求解时，总是作出在当前看来是最好的选择。也就是说，不从整体上加以考虑，<br>它所作出的仅仅是在某种意义上的局部最优解（是否是全局最优，需要证明）。</p>
<h2 id="最优装载问题"><a href="#最优装载问题" class="headerlink" title="最优装载问题"></a>最优装载问题</h2><p>问题提出：有一天海盗们截获了一艘装满各种各样古董的货船，每一件都价值连城，一旦打碎就是去了价值，<br>海盗船载重量为C，每件固定的重量为wi，海盗们该如何尽可能装载最多数量的古董呢？</p>
<p>古董重量清单：<img src="https://img-blog.csdnimg.cn/20190718174241296.png" alt="在这里插入图片描述"><br>算法设计：</p>
<ol>
<li>船载重量固定为C，只要每次选择重量最小的古董，直到不能再装为止，这样装载的古董数量最大，<br> 这就是贪心策略；</li>
<li>把古董按重量从小到大排序，根据策略选出尽可能多的古董。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190718174337544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="教室调度问题"><a href="#教室调度问题" class="headerlink" title="教室调度问题"></a>教室调度问题</h2><p>问题提出：<br>假设有如下课程表，你希望将尽可能多的课程安排在某间教室上。<br>但是你没法让这些课都在这间教室上，因为有些课的上课时间有冲突。</p>
<p><img src="https://img-blog.csdnimg.cn/20190718174437283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190718174509332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>你希望在这间教室上尽可能多的课。如何选出尽可能多且时间不冲突的课程呢？<br>具体做法如下：<br>(1) 选出结束最早的课，它就是要在这间教室上的第一堂课。<br>(2) 接下来，必须选择第一堂课结束后才开始的课。同样，你选择结束最早的课，这将是要在这间教室上的第二堂课。<br>重复这样做就能找出答案！</p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>问题提出：假设山洞中有n种宝物，每种宝物有一定重量w和相应的价值v，毛驴运载能力<br>一种宝物只能拿一样，宝物可分割。怎样才能使毛驴运走宝物的价值最大呢？</p>
<p>解题思路：<br>可以尝试三种贪心策略：</p>
<ol>
<li>每次挑选价值最大的装东西入背包；</li>
<li>每次挑选最重的东西；</li>
<li>每次选取单位重量价值最大的东西。</li>
</ol>
<p>算法设计：</p>
<ol>
<li>计算出每件宝物的性价比，按照从高到低排序；</li>
<li>根据贪心策略，按性价比从大到小选取宝物，直到达到毛驴的运载能力。每次选择宝物后判断是否<br>小于m，如果不小于则取走宝物的一部分，程序结束</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190718174657892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="不同问题的求借策略"><a href="#不同问题的求借策略" class="headerlink" title="不同问题的求借策略"></a>不同问题的求借策略</h2><p>想一下如果宝物不可分割，贪心算法得到的是否是最优解？</p>
<p>注意: 物品可分割的装载问题称为背包问题，不可分割问题的装载问题称为0-1背包问题。<br>0-1背包问题不具有贪心选择性质，贪心算法不能得到全局最优解，仅仅是最优解的近似解。<br>0-1背包问题可用动态规划算法求解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/贪心算法与动态规划-Python语言实现/" data-id="cjyigf8wi000gpb5ecq9uwyld" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法习题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/算法习题/" class="article-date">
  <time datetime="2019-07-25T01:20:01.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/算法习题/">算法习题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>1.根据身高重建队列问题：<br><img src="https://img-blog.csdnimg.cn/20190718210220918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">代码：</p>
<pre><code>def rec(people):
people = sorted(people, key=lambda x: (x[0], x[1]),reverse=True)
Line = []
for each in people:
    Line.insert(each[1], each)
return Line


print(rec([[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]))</code></pre><p><img src="https://img-blog.csdnimg.cn/2019071823010517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>l = []
def minimumTotal(triangle, i, j, sum=0):
    if j &gt; len(triangle) - 1 or i &gt; len(triangle) - 1:
        return sum
    sum += triangle[i][j]
    if i == len(triangle) - 1:
        l.append(sum)
    minimumTotal( triangle, i + 1, j, sum)
    minimumTotal(triangle, i + 1, j + 1, sum)
    return min(l)
triangle = [
    [2],
    [3, 4],
    [6, 5, 7],
    [4, 1, 8, 3],
    [2, 3, 4, 5, 6]
]
a = minimumTotal(triangle, 0, 0,0)
print(a)</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/算法习题/" data-id="cjyigf8wk000ipb5ega356k7o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-多进程编程习题-Python语言实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/多进程编程习题-Python语言实现/" class="article-date">
  <time datetime="2019-07-25T01:18:07.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/多进程编程习题-Python语言实现/">多进程编程习题(Python语言实现)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>~## IP 地址归属地批量查询任务<br><strong>注意: 使用创建子类的方式实现多线程任务</strong></p>
<p>实现代码：</p>
<pre><code>import json
import requests
from threading import Thread


class GetHostAliveThread(Thread):
    def __init__(self, ip):
        super(GetHostAliveThread, self).__init__()
        self.ip = ip

def run(self):
    url = &apos;http://ip-api.com/json/%s&apos; % (ip)
    count = requests.get(url).text
    dict_data = json.loads(count)
    city = dict_data.get(&apos;city&apos;)
    country = dict_data.get(&apos;country&apos;)
    print(&apos;%s的所在城市为%s&apos; % (self.ip, city))
    print(&apos;%s的所在城市为%s&apos; % (self.ip, country))


if __name__ == &apos;__main__&apos;:
    for i in range(25):
        ip = str(&apos;1.1.1.&apos;) + str(1 + i)
        thread = GetHostAliveThread(ip)
        thread.start()</code></pre><h2 id="基于多线程的批量主机存活探测"><a href="#基于多线程的批量主机存活探测" class="headerlink" title="基于多线程的批量主机存活探测"></a>基于多线程的批量主机存活探测</h2><p>项目描述: 如果要在本地网络中确定哪些地址处于活动状态或哪些计算机处于活动状态,<br>则可以使用此脚本。我们将依次 ping 地址, 每次都要等几秒钟才能返回值。这可以在 Python<br>中编程,在 IP 地址的地址范围内有一个 for 循环和一个 os.popen(“ping -q -c2”+ ip)。<br>项目瓶颈: 没有线程的解决方案效率非常低,因为脚本必须等待每次 ping。<br><strong>注意: 使用实例化对象的方式实现多线程任务</strong></p>
<p>实现代码：</p>
<pre><code>import json
import requests
from threading import Thread
import pymysql
conn = pymysql.connect(host=&apos;172.25.254.149&apos;, user=&apos;root&apos;, password=&apos;990038&apos;, db=&apos;mysql&apos;)#连接数据库
cursor = conn.cursor()#设立邮标
# create_sqli = &apos;create table IP(ipid varchar(20),ipcity varchar(20),ipcountry varchar(20));&apos;（如果没有表则进行建表）
# cursor.execute(create_sqli)

class GetHostAliveThread(Thread):
    def __init__(self, ip):
        super(GetHostAliveThread, self).__init__()
        self.ip = ip

def run(self):
    url = &apos;http://ip-api.com/json/%s&apos; % (ip)
    count = requests.get(url).text
    dict_data = json.loads(count)
    city = dict_data.get(&apos;city&apos;)
    country = dict_data.get(&apos;country&apos;)
    #print(&apos;%s的所在城市为%s&apos; % (self.ip, city))
    #print(&apos;%s的所在城市为%s&apos; % (self.ip, country))
    insert_sqli = &apos;insert into IP(ipid,ipcity,ipcountry) values(&quot;%s&quot;, &quot;%s&quot;, &quot;%s&quot;);&apos; % (ip, city, country)#将信息导入数据库
    print(insert_sqli)
    cursor.execute(insert_sqli)
    conn.commit()#上传修改


if __name__ == &apos;__main__&apos;:
    for i in range(25):
        ip = str(&apos;1.1.1.&apos;) + str(1 + i)
        thread = GetHostAliveThread(ip)
        thread.start()
        cursor.close()
        conn.close()</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/多进程编程习题-Python语言实现/" data-id="cjyigf8w10007pb5ep67su88m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库对象映射SQLAachemy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/数据库对象映射SQLAachemy/" class="article-date">
  <time datetime="2019-07-25T01:14:40.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/数据库对象映射SQLAachemy/">数据库对象映射SQLAachemy</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>什么是ORM？</strong><br>ORM，即Object-Relation Mapping(对象关系映射)，它的作用是在关系型数据库和业务实体对象之间做一个映射，这样，我们在具体的操作业务对象的时候，就<strong>不需要再去和复杂的SQL语句打交道，</strong>只需要简单的操作对象的属性和方法。</p>
<p><strong>什么是SQLAIchemy？</strong><br>SQLAIchemy是Python编程语言下的一款开源软件。提供了SQL工具包以及对象关系映射工具，为高校和高性能的数据库访问设计，实现了完整的企业级别持久模型。</p>
<p><img src="https://img-blog.csdnimg.cn/20190722092020536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>安装sqlalchemy步骤：</strong><br>1.需要一台安装MYSQL数据库的机器<br>2.安装模块：pip3 install sqlalchemy<br>3.查看版本信息</p>
<p><strong>操作信息：</strong><br>在sqlalchemy中，session用于创建程序与数据库之间的会话。所有对象的载入和保存都需要通过session对象。</p>
<p><img src="https://img-blog.csdnimg.cn/2019072209270984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>一个映射对应着一个Python类，用来表示一个表的结构。</strong></p>
<pre><code>#基于这个基类来创建我们的自定义类，一个类就是一个数据库表。
class Person(Base):
    __tablename__ = &apos;userinfo&apos;
    id =     Column(Integer,primary_key=True)
    name = Column(String(32))
    email = Column(String(32),unique = True)

    def __repr__(self):
        return &quot;&lt;Person(name=&apos;%s&apos;)&gt;&quot; % self.name
if __name__ == &apos;__main__&apos;:
    #检查表的存在性，如果不存在的话会执行表的创建工作。
    Base.metadata.create_all(engine)</code></pre><p><strong>添加单条数据</strong></p>
<pre><code>#创建一个person对象
person = Person（name=‘粉丝’）
#设置邮箱地址
person.email = &apos;westos.qq.com&apos;
#添加person对象，但是仍然没有提交到数据库
session.add(person)
#提交数据库
session.commit()</code></pre><p><strong>添加多条数据</strong></p>
<pre><code>seeion.add_all([Person(name=&apos;小A&apos;,email=&apos;a@westos.org&apos;)
                         Person(name=&apos;小B&apos;,email=&apos;b@westos.org&apos;)]    
session.commit()</code></pre><p><strong>查找数据</strong><br>sqlalchemy模块中，朝朝数据给提供了query()的方法</p>
<pre><code>#限制返回的数据：all-所有数据，first-第一条数据
print(session.query(Person).all())
print(session.query(Person).first())

#筛选数据
print(session.query(Person).filter_by(name=&apos;小A&apos;).all（）)
print(session.query(Person).filter_by(name=&apos;小A&apos;.first())
print(session.query(Person).filter_by(name=&apos;小A&apos;).one_or_none())</code></pre><p><strong>删除数据</strong></p>
<pre><code>person = session.query(Person).filter_by(name=&quot;小A&quot;).first()
session.delete(person)
print(session.query(Person).all())</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/数据库对象映射SQLAachemy/" data-id="cjyigf8w5000apb5efwmt59w7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络编程作业题目" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/网络编程作业题目/" class="article-date">
  <time datetime="2019-07-25T01:11:53.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/网络编程作业题目/">网络编程作业题目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="一-常见网络编程面试题目"><a href="#一-常见网络编程面试题目" class="headerlink" title="一. 常见网络编程面试题目"></a><strong>一. 常见网络编程面试题目</strong></h2><p><strong>1.简述 OSI 七层协议。</strong><br>1)应用层——文件传输，电子邮件，文件服务，虚拟终端<br>2)表示层——数据格式化，代码转换，数据加密<br>3)会话层——接触与建立与别的接口的联系<br>4)传输层——提供对端口的协议，如TCP/UDP<br>5)网络层——为数据包选择路由<br>6)数据链路层——传输有地址的帧以及错误检测功能<br>7)物理层——以二进制数据形式在物理媒体上传输数据</p>
<p><strong>2. 简述 TCP/IP 四层协议。</strong><br>1)主机到网络层<br>2)网络互连层，网络互连层是整个TCP/IP协议栈的核心。它的功能是把分组法网目标或主机。同时，为了尽快的发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。<br>3)传输层，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议，即TCP和UDP。<br>4)应用层，将OSI参考模型中的会话层和表示层的功能合并到应用层实现。<br><strong>3. TCP 和 UDP 的区别是什么?</strong><br>根据可靠性来说TCP是可靠的，而UDP是不可靠的。<br>根觉连接性来讲，TCP是面向连接，但是UDP是无连接的。<br>根据传输的数据类型来讲：TCP是面向子节流，但是UDP是面向报文。<br>效率：UDP的传输效率较高，TCP的传输效率较低。</p>
<p><strong>4. TCP 连接建立的时候 3 次握手的具体过程,以及其中的每一步是为什么?</strong><br>客户端一开始向服务端发送一个数据包，服务端会向他返回一个确认收到的数据包，并且向客户端也发送回一个新的数据包，此时客户端收到服务端新发的数据包后会向服务端返回一个确认的数据包。在三次握手中，客户端和服务端都发送了两个包SYN和ACK，只不过服务端是一次性发送，但是客户端的两个包是分两次发送的。<br><img src="https://img-blog.csdnimg.cn/2019072414171888.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>5. TCP 断开连接的具体过程,其中每一步是为什么那么做?</strong><br>客户端与服务端断开连接时需要四次挥手，指的是A端向B端发送断开请求，发送一个数据包，B端收到后可能此时数据没有传输完成，所以B端并不会马上向A端确认，而是发送了一个确认序号，表示收到信息，但是无法现在立刻处理。第三次挥手为当B端数据传输完成后，此时B端可以断开连接，向A端发送断开连接请求，表示此时可以断开连接。第四次挥手是A端收到B端发送的数据包后，会向B端发送确认信号，经过两个MSL时长后断开连接。</p>
<p><strong>6. TCP 的十一种状态?</strong><br>1)LISTEN——侦听来自远方TCP端口的连接请求<br>2)SYN_SENT——在发送连接请求后等待对连接请求的确认<br>3)STN_RECEIVED —— 在收到和发送一个连接请求后对连接请求的确认<br>4)ESTABLISHED——代表一个打开的连接，数据可以传送给用户<br>5)FIN_WAIT_1 ——等待远程TCP的连接终端请求，或者先前的连接起来的<br>6)FIN_WAIT_2—— 从远程TCP等待连接中断请求<br>7)CLOSE_WAIT —— 等待本地用户发来的连接中断请求<br>8)CLOSING——等待远程TCP对连接中断的确认<br>9)LAST_ACK——等待原来法相远程TCP的连接中断请求的确认<br>10)TIME_WAIT——等待原来法相远程TCP的连接中断请求的确认<br>11)CLOSED——没有任何连接状态</p>
<p><strong>7. 什么是 socket?简述基于 tcp 协议的套接字通信流程。</strong><br>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部。 </p>
<p> 服务端先初始化Socket实例化一个类拿到对象（才能调用下面的接口），然后绑定IP端口(bind)，监听(listen)就是说客户端可以来连我了，调用accept接收链接；这时客户端初始化一个socket，然后connect与服务端建立好双向链接与accept对应。客户端发送请求数据，服务端处理请求并给客户端回应数据，这样一个通信循环；最后关闭套接字，一次交互结束。</p>
<p><strong>8. 简述基于 tcp 协议的套接字通信流程。</strong><br>服务端：<br>1.创建socket对象<br>2.创建地址和端口<br>3.监听<br>4.接收客户端的连接<br>5.接收客户端发送的消息<br>6.给客户端发送消息<br>7.关闭socket对象<br>客户端：<br>1.创建一个socket对像<br>2.连接服务端<br>3.给服务端发送信息<br>4.接收服务端发来的消息<br>5.关闭客户端socket对象</p>
<p><strong>9. TCP 为什么不是两次连接?而是三次握手?</strong><br>因为TCP协议是面向于连接的，它发送的连接请求需要获得另一端的确认，才可以真正意义上的连接成功。</p>
<p><strong>10. 为何基于 tcp 协议的通信比基于 udp 协议的通信更可靠?</strong><br> tcp协议一定是先建好双向链接，发一个数据包要得到确认才算发送完成，没有收到就一直给你重发；udp协议没有链接存在，udp直接丢数据，不管你有没有收到。</p>
<p><strong>12. 网络编程中设计并发服务器,使用多进程与多线程,请问有什么区别?</strong><br>1.进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。<br>2.线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。<br>两者都可以提高程序的并发度，提高程序运行效率和响应时间。<br>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP(Symmetric Multi-Processing，对称多处理结构的简称，是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。)机器上运行，而进程则可以跨机器迁移。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/网络编程作业题目/" data-id="cjyigf8wh000fpb5e7lj5xp4w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络编程-Python实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/网络编程-Python实现/" class="article-date">
  <time datetime="2019-07-24T09:40:57.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/网络编程-Python实现/">网络编程(Python实现)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>[toc]</p>
<h2 id="网络通信概述"><a href="#网络通信概述" class="headerlink" title="网络通信概述"></a>网络通信概述</h2><p><strong>什么是网络？</strong><br>网络就是一种辅助双法或者多方能连接在一起的工具。<br>如果没有网络，可想单机的世界是多么孤单。</p>
<p><strong>使用网络的目的：</strong><br>联通多方然后进行通信用的，即把数据从一方传递给另外一方。<strong>网络编程</strong>就是，让在不同的电脑上的软件能够数据传递，即<strong>进程之间的通信</strong>。</p>
<h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p><strong>如何实现网络通信？——协议</strong><br>有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同语言的人就不行了，为了解决不同种族人之间的语言沟通障碍，现规定国际通用语言是英语，这就是一个规定，这是协议。</p>
<p><strong>网络通信协议是什么？</strong><br>问题：不同种类之间的计算机到底是怎么进行数据传递的呢？<br>答：就像说不同语言的人沟通一样，只要有一种大家都认可都遵守的协议即可，那么这个计算机都遵守的网络通信协议叫做TCP/IP协议。</p>
<p><strong>TCP/IP协议(族)</strong><br>互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP/IP协议，所以大家把互联网的协议简称为TCP/IP协议。<br><img src="https://img-blog.csdnimg.cn/20190724094616852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>什么是IP地址</strong><br>ip地址：用来在网络中标记一台电脑的一串数字，比如192.168.1.1；在本地局域网上是唯一的。<br><img src="https://img-blog.csdnimg.cn/20190724094955452.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>私有IP</strong><br>网络IP中，国际规定有一部分IP地址是用于局域网使用，也就是属于私网IP，不再公网中使用的，他们的范围是：<br> 10.0.0.0～10.255.255.255<br>    172.16.0.0～172.31.255.255<br>    192.168.0.0～192.168.255.255</p>
<p><strong>回环地址IP</strong><br>IP地址127.0.0.1代表本地IP地址，等价于localhost，用<a href="http://127.0.0.1就可以测试本集中配置的WEB服务器。" target="_blank" rel="noopener">http://127.0.0.1就可以测试本集中配置的WEB服务器。</a></p>
<p><strong>子网掩码</strong><br>子网掩码不能呢个单独存在，它必须结合<strong>IP地址</strong>一起使用。</p>
<p><strong>子网掩码的作用：</strong> 将某个IP地址分成网络地址和主机地址两部分，子网掩码的设定必须遵循一定的规则，用来判断两个IP是否在同一个网络。<br>A: 172.25.254.18/24<br>B: 172.25.0.10/24</p>
<p><strong>端口</strong><br>1.端口就好像一个房子的门，是出入这间房子的必经之路。<br>2.端口号只有整数，范围是从0到65535<br>熟悉的服务及其对应的端口号：<br>http ： 80<br>mysql ； 3306<br>https ：443<br>ssh ：22<br>ldqp ： 289</p>
<h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><p><strong>本地进程间通信（IPC）</strong><br>1.队列<br>2.同步<br>3.管道</p>
<p><strong>网络进程间通信</strong><br>问题： 本地通过进程PID来唯一标示一个进程，在网络中如何唯一标示一个进程？<br>答：网络层“IP地址”可以唯一标示网络中的主机，而传输层的”协议+端口“可以唯一标示主机中的应用程序（进程）。因此利用<strong>IP地址，协议，端口</strong>就可以标示网络的进程。</p>
<p><strong>什么是socket？</strong><br>答：socket（简称套接字）是进程间的一种通信方式，能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于Socket来完成通信的。</p>
<p><strong>创建socket</strong><br>在 Python 中 使⽤socket 模块的函数 socket 就可以完成：     socket.socket(AddressFamily, Type)<br>    1). Address Family:<br>        AF_INET: IPV4⽤于 Internet 进程间通信<br>        AF_INET6: IPV6⽤于 Internet 进程间通信<br>    2). Type：套接字类型<br>        SOCK_STREAM: 流式套接字，主要⽤于 TCP 协议<br>        SOCK_DGRAM: 数据报套接字，主要⽤于 UDP 协 议</p>
<h3 id="socket编程-UDP"><a href="#socket编程-UDP" class="headerlink" title="socket编程(UDP)"></a>socket编程(UDP)</h3><p><strong>UDP介绍</strong><br>1.UDP用户数据报协议，是一个无连接的简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证他们能到达目的地，由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重法等机制，故而传输速度很快。<br>2.UDP是一种面向无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p>
<p><strong>UDP特点</strong><br>UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP传输数据时有大小限制，每个传输的数据报必须限定在64KB以内。UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。<br><img src="https://img-blog.csdnimg.cn/20190724105514934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    <strong>服务端代码框架：</strong></p>
<pre><code>import socket
#1.实例化socket对象
udpServer = socket.socket(family=socket.AF_INET,type=socket.SOCK_DGRAM)
#2.绑定IP和端口
#172.25.254.250
#0.0.0.0代表开放所有的IP地址
udpServer.bind((&apos;0.0.0.0&apos;,9001))
print(&apos;等待客户端UDP的连接......&apos;)

#3.接收客户端的连接
recvdata,address = udpServer.recvfrom(1024)
print(&apos;接收到客户端的数据：&apos;,recvdata.decode(&apos;utf-8&apos;))

#4.给客户端回复信息
udpServer.sendto(b&quot;hello client&quot;,address)
#5.关闭socket对象
udpServer.close()</code></pre><p><strong>客户端代码框架：</strong></p>
<pre><code>import socket

udpClient = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
udpClient.sendto(b&apos;hello server&apos;, (&apos;172.25.254.49&apos;, 9001))
recvData, address = udpClient.recvfrom(1024)
print(&apos;接收服务端的数据：&apos;, recvData.decode(&apos;utf-8&apos;))
udpClient.close()</code></pre><p><strong>UDP网络程序框图</strong><br><img src="https://img-blog.csdnimg.cn/20190724111108568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="socket编程-TCP"><a href="#socket编程-TCP" class="headerlink" title="socket编程(TCP)"></a>socket编程(TCP)</h3><p><strong>TCP详解：<br>TCP传输控制协议（英语：Transmission Control Protocol，缩写为TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</strong></p>
<p>三次握手与四次挥手：<br><img src="https://img-blog.csdnimg.cn/20190724111418140.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图：存在两个包，同步序列号SYN 确认包ACK<br><strong>四种状态：</strong> SYN_SENT, LISTEN, SYN_RECV, ESTABLISHED<br>在三次握手中，客户端和服务器端都发送两个包SYN和ACK，只不过服务器端的两个包是一次性发过来的，客户端的两个包是分两次发送的。</p>
<p><strong>TCP数据传输：</strong><br><img src="https://img-blog.csdnimg.cn/20190724112015525.jpg" alt="在这里插入图片描述"><br><strong>TCP四次挥手：</strong><br><img src="https://img-blog.csdnimg.cn/2019072411213786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>四次挥手</strong><br>当A端和B端要断开连接时，需要四次握手，这里称为四次挥手。</p>
<p>断开连接请求可以由客户端发出，也可以由服务器端发出，在这里我们称A端向B端请求断开连接。</p>
<p>第一次挥手</p>
<p>A端向B端请求断开连接时会向B端发送一个带有FIN标记的报文段，这里的FIN是Finish的意思。</p>
<p>第二次挥手</p>
<p>B端收到A发送的FIN后，B段现在可能现在还有数据没有传完，所以B端并不会马上向A端发送FIN，而是先发送一个确认序号ACK，意思是说“你发的断开连接请求我收到了，但是我现在还有数据没有发完，请稍等一下呗”。</p>
<p>第三次挥手</p>
<p>当B端的事情忙完了，那么此时B端就可以断开连接了，此时B端向A端发送FIN序号，意思是这次可以断开连接了。</p>
<p>第四次挥手</p>
<p>A端收到B端发送的FIN后，会向B端发送确认ACK，然后经过两个MSL时长后断开连接。</p>
<p>MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间</p>
<p><img src="https://img-blog.csdnimg.cn/20190724112544330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码实现服务端框架：</p>
<pre><code>import socket

# 1.创建一个socket对象；
# family指定使用IP协议的版本：IPV4：AF_INET; ipv6:AF_INET6
# type指定传输层使用的协议类型：TCP（SOCKET.SOCK_STREAM）,UDP(SOCK_DGRAM)
server = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
# 2.绑定一个IP和端口，供客户端来连接；
server.bind((&apos;172.25.254.250&apos;, 4002))
# 3.监听是否有客户端连接
server.listen(5)
print(&apos;服务端正在启动......&apos;)
# 4.接收客户端的连接，accept() -&gt; (socket object,address info)
clientSocket, address = server.accept()
print(&apos;客户端的地址：&apos;, address)
# 5.接收客户端发送的信息
recvData = clientSocket.recv(1024)
print(&quot;服务端接收的信息：&quot;, recvData.decode(&apos;utf-8&apos;))
# 6.给客户端回复消息，send（self,data:**bytes***,flags:int = .....）
clientSocket.send(&apos;你好，客户端&apos;.encode(&apos;utf-8&apos;))
# 7.关闭服务器端socket对象
server.close()</code></pre><p>代码实现客户端框架：</p>
<pre><code>import socket

# 1.创建一个socket对象；
# family指定使用IP协议的版本：IPV4：AF_INET; ipv6:AF_INET6
# type指定传输层使用的协议类型：TCP（SOCKET.SOCK_STREAM）,UDP(SOCK_DGRAM)
client = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
# 2.连接服务器(ip,port)
client.connect((&apos;172.25.254.250&apos;,4002))
# 3.给服务端回复消息，send（self，data：***bytes***，flages：int=...）-&gt; int:...
client.send(&apos;你好，服务器&apos;.encode(&apos;utf-8&apos;))

# 4.接收服务端回复的消息
recvData = client.recv(1024)
print(&apos;客户端接收的信息：&apos;, recvData.decode(&apos;utf-8&apos;))

# 5.关闭客户端socket对象
client.close()</code></pre><p><strong>应用：模拟QQ聊天</strong><br>代码实现（服务端）：</p>
<pre><code>import socket
# 1.创建对象
server = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
# 2.创建地址和端口
server.bind((&apos;172.25.254.49&apos;, 4002))
# 3.监听
server.listen(5)
print(&apos;服务端正在启动.....&apos;)
# 4.接收客户端的连接
ServerSocket, address = server.accept()
while True:
    # 5.接收客户端发送的消息
    recvData = ServerSocket.recv(1024)
    recv = recvData.decode(&apos;utf-8&apos;)
    print(&apos;服务端接收的信息：&apos;,recv )
    if recv == &apos;bye&apos;:
        break
    # 6.给客户端发送消息
    send_data = input(&quot;server:&gt;&gt;&quot;).encode(&apos;utf-8&apos;)
    ServerSocket.send(send_data)

# 7.关闭socket对象
server.close()
ServerSocket.close()</code></pre><p>客户端：</p>
<pre><code>import socket

# 1.创建一个socket对像；
client = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
# 2.连接服务端
client.connect((&apos;172.25.254.49&apos;, 4022))
# 3.给服务端发送信息
while True:
    send_data = input(&apos;client:&gt;&gt;&apos;).encode(&apos;utf-8&apos;)
    client.send(send_data)

    if send_data.decode(&apos;utf-8&apos;) == &apos;bye&apos;:
        break
# 5.关闭客户端socket对象
client.close()</code></pre><h2 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h2><p>并发服务器是socket应用编程中最常见的应用模型。根据连接方式分为长连接和短连接.<br><strong>长连接</strong>:建立SOCKET连接后不管是否使用都保持连接。<br><strong>短连接</strong>：双方都有数据交互时，建立TCP连接，数据发送完成后断开连接。</p>
<p><strong>并发服务器模型根据处理方式可分为同步方式和异步方式：</strong><br><img src="https://img-blog.csdnimg.cn/20190724120234663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>单进程服务器：</strong><br>同⼀时刻只能为⼀个客户进⾏服务，不能同时为多个客户服务<br>类似于找⼀个“明星”签字⼀样，客户需要耐⼼等待才可以获取到服务</p>
<p><strong>多进程服务器：</strong><br>优点: 通过为每个客户端创建⼀个进程的⽅式，能够同时为多个客户端进⾏服务<br>缺点: 当客户端不是特别多的时候，这种⽅式还⾏，如果有⼏百上千个，就不 可取了，因为每次创建进程等过程需要好较⼤的资源<br><img src="https://img-blog.csdnimg.cn/20190724120151352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190724120207344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码实现框架(服务端)：</p>
<pre><code>import socket
from multiprocessing import Process


def dealWithClient(ServerSocket, clientAddress):
    while True:
        # 5.接收客户端发送的消息
        recvData = ServerSocket.recv(1024)
        recv = recvData.decode(&apos;utf-8&apos;)
        print(clientAddress[0] + str(clientAddress[1]) + &apos;:&gt;&apos; + recv)
        if recv == &apos;quit&apos;:
            break
    ServerSocket.close()


# 1.创建对象
server = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
# 2.创建地址和端口
server.bind((&apos;172.25.254.49&apos;, 4022))
# 3.监听
server.listen(5)
print(&apos;服务端正在启动.....&apos;)
# 4.接收客户端的连接

while True:
    ServerSocket, address = server.accept()
    p = Process(target=dealWithClient, args=(ServerSocket, address))
    p.start()</code></pre><p><strong>多线程服务器</strong><br><img src="https://img-blog.csdnimg.cn/20190724134528139.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>gevent版-TCP服务器</strong><br><img src="https://img-blog.csdnimg.cn/2019072413461012.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190724134644809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/网络编程-Python实现/" data-id="cjyigf8wj000hpb5ero9v8ot7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-多任务编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/多任务编程/" class="article-date">
  <time datetime="2019-07-24T09:33:39.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/多任务编程/">多任务编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>[toc]</p>
<h2 id="多任务编程"><a href="#多任务编程" class="headerlink" title="多任务编程"></a>多任务编程</h2><p>现实生活中的多任务：<br>有很多的场景中的事情是同时进行的，比如开车的时候，手和脚共同来驾驶汽车。再比如唱歌和跳舞也是同时进行的。</p>
<p><strong>什么叫”多任务”？</strong><br>就是操作系统可以同时运行多个人物。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有三个任务正在进行。还有很多任务悄悄的正在后台同时运行着，只是桌面上没有现实而已。</p>
<p><strong>单核CPU如何实现”多任务”呢？</strong><br>操作系统轮流让各个任务交替执行，每个任务执行0.01秒，这样反复执行下去。表面上看，每个任务交替执行，但CPU的执行速度实在是太快了，感觉就像所有任务都在同时执行一样。<br><img src="https://img-blog.csdnimg.cn/20190722101341379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>多核CPU如何实现”多任务”呢?</strong></p>
<p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多与CPU的核心数量，所以操作系统也会自动把很多任务轮流调度到每个核心上执行。<br><img src="https://img-blog.csdnimg.cn/20190722105118297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>编写完毕的代码，在没有运行的时候，称之为<strong>程序</strong>。<br>正在运行着的代码，就成为<strong>进程</strong>。<br><strong>注意</strong>：进程，除了包含代码以外，还需要运行的环境等，所以和程序是由区别的</p>
<p><img src="https://img-blog.csdnimg.cn/20190722110156741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>创建子进程</strong><br>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：<br><img src="https://img-blog.csdnimg.cn/20190722110410416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Python中创建子进程的常用函数：</p>
<pre><code>&quot;&quot;&quot;
os.fork()
os.getpid()   #获取当前进程的pid (process id)
os.getppid()    #获取当前进程的父进程pid(parent process id)
&quot;&quot;&quot;
import os
print(&quot;当前进程(pid = %d)正在运行......&quot; %(os.getpid()))
#在pycharm编写代码，程序的父进程就是pycharm；
print(&quot;当前进程的父进程为(pid=%d)正在运行.....&quot; %(os.getppid()))
print(&quot;开始创建子进程.....&quot;)

pid = os.fork()
if pid == 0;
    print(&apos;这是子进程返回的是0，子进程的pid为%d,父进程为%d&apos; %(os.getpid(),os.getppid()))
else:
    pring(&quot;这是父进程返回的，返回值为子进程的pid，为%d&quot; %(pid))</code></pre><p><strong>fork函数的作用：</strong><br>1.执行到os.fork()时，操作系统会创建一个新的进程复制父进程的所有信息到子进程中。<br>2.普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次。<br>3.父进程和子进程都会从fork()函数中得到一个返回值，子进程返回的是0，而父进程中返回子进程的id号。</p>
<p><strong>多进程修改全局变量</strong><br>多进程中，每个进程中所有数据(包括全局变量)都各拥有一份，互不影响。</p>
<p>由于Windows没有fork调用，由于Python是跨平台的，multiprocessing模块就是跨平台版本的多进程模块。multiprocessing模块提供了一个Processing模块提供了一个Process类来代表一个进程对象。</p>
<p>Process([group [, target [, name [, args [, kwargs]]]]])<br>    target：表示这个进程实例所调⽤对象；<br>    args：表示调⽤对象的位置参数元组；<br>    kwargs：表示调⽤对象的关键字参数字典；<br>    name：为当前进程实例的别名；<br>    group：⼤多数情况下⽤不到；<br>    Process类常⽤⽅法：<br>    is_alive()：    判断进程实例是否还在执⾏；<br>    join([timeout])：    是否等待进程实例执⾏结束，或等待多少秒；<br>    start()：        启动进程实例（创建⼦进程）；<br>    run()：        如果没有给定target参数，对这个对象调⽤start()⽅法时，就将执 ⾏对象中的run()⽅法；<br>    terminate()：    不管任务是否完成，⽴即终⽌；</p>
<p><strong>Process类常⽤属性</strong>：<br>    name：当前进程实例别名，默认Process-N，N为从1开始计数；<br>    pid：当前进程实例的PID值；</p>
<p><strong>多进程编程方法一：实例化对象</strong></p>
<pre><code>from multiprocessing import Process
for i in range(len(expression_list)):
    p = Process(target=eval_formula,args=(expression_list[i],))
    p.start()
    p.join()
def eval_formula(formula):</code></pre><p>示例1：</p>
<pre><code>from multiprocessing import Process
import time
def task1(): #定义第一个任务
    print(&apos;正在听音乐&apos;)
    time.sleep(1) #运行过后休眠1s
def task2(): #定义第二个任务
    print(&apos;正在编程。。。。&apos;)
    time.sleep(0.5) #运行完成休眠0.5s
def no_multi(): #不使用多进程编程运行的方法
    for i in range(2):
        task1()
    for i in range(5):
        task2()
def use_multi(): #使用多进程编程使程序运行
    processes = [] #创建一个列表，将运行次每次任务的过程存入列表
    for i in range(2):
        p = Process(target=task1,)
        p.start()
        processes.append(p)
    for i in range(5):
        p = Process(target=task2)
        p.start()
        processes.append(p)
    [process.join() for process in processes] #使前两个函数任务阻塞，运行完后方可运行主函数(当需要计算函数运行时间的时候需要用)
if __name__ == &apos;__main__&apos;:
    start_time = time.time()
    use_multi() #调用多进程方法，查看多进程运行所需时间
    end_time = time.time()
print(end_time-start_time)</code></pre><p><img src="https://img-blog.csdnimg.cn/201907221159147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以上为多进程编程运行所需要的时间，如果单进程的话时间应该为2<em>1+5</em>0.5=4.5s</p>
<p><strong>多进程编程方法2</strong></p>
<p>改写run函数：</p>
<p><img src="https://img-blog.csdnimg.cn/20190722134319851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><p><strong>为什么需要进程池Pool？</strong><br>当被操作对象数目不大时，可以直接利用multiprocessing中的Process动态成生多个进程，十几个还好，但如果是上百个，上千个目标，手动的去限制进程数量却又太过繁琐，此时可以发挥进程池的功效。</p>
<p>Pool可以提供指定数量的进程供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来它。</p>
<p><strong>进程池实现1：</strong></p>
<pre><code>import multiprocessing
p = multiprocessing.Pool(multiprocessing.cpu_count())
result = p.map(ecal_formula,expression_list)
p.close()
p.join()

def eval_formual(formula):
    #evalueates the expression</code></pre><p><strong>进程池实现2：</strong></p>
<pre><code>import multiprocessing
def job(id):

    print(&quot;start %d....&quot; % (id))

    print(&quot;end %d....&quot; % (id))
# 创建进程池对象
pool = multiprocessing.Pool(processes=4)
# 给进程池分配任务;
for i in range(10):
    pool.apply_async(job, args=(i + 1,))
pool.close()
# 等待所有的子进程执行结束， 关闭进程池对象;
pool.join()
print(&quot;所有任务执行结束.....&quot;)</code></pre><p><strong>进程池实现3：</strong></p>
<pre><code>from concurrent.futures import ProcessPoolExecutor
def job(id):
    print(&apos;start %d...&apos; % (id)&apos;)
    print(&quot;end %d...&quot; % (id))
pool = ProcessPoolExecutor(max_workers = 4)
#
#for id in ranger(10):
#    #分配任务给子进程，并且返回一个Future对象；
#         f1 = pool.submit(job,args=(id))
#     #判断子进程是否执行结束
#        print(f1.done())
#    #查看该子进程执行的结果
#        print(f1,range(10))</code></pre><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><strong>为什么需要进程之间的通信？</strong><br><img src="https://img-blog.csdnimg.cn/20190722141727156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>如何实现进程间的通信？</strong><br><img src="https://img-blog.csdnimg.cn/20190722141959367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>消息队列</strong><br>可以使⽤multiprocessing模块的Queue实现多进程之间的数据传递，<strong>Queue 本身是⼀个消息列队程序。</strong><br>Queue.qsize()：    返回当前队列包含的消息数量；<br>Queue.empty()：    如果队列为空，返回True，反之False ；<br>Queue.full()：    如果队列满了，返回True,反之False；<br>Queue.get([block[, timeout]])：<br>    获取队列中的⼀条消息，然后将其从列队中移除，block默认值为True；<br>Queue.get_nowait()：<br>    相当Queue.get(False)；<br>Queue.put(item,[block[, timeout]])：<br>    将item消息写⼊队列，block默认值 为True；<br>Queue.put_nowait(item)：<br>    相当Queue.put(item, False)</p>
<p><strong>消息队列实例：</strong></p>
<pre><code>import time</code></pre><p>import multiprocessing</p>
<p>class Producer(multiprocessing.Process):<br>    def <strong>init</strong>(self, queue):<br>        super(Producer, self).<strong>init</strong>()<br>        self.queue = queue</p>
<pre><code>def run(self):
    for i in range(10):
        self.queue.put(i)
        time.sleep(0.1)
        print(&apos;传递信息，内容为%s&apos; % (i))


class Consumer(multiprocessing.Process):
    def __init__(self, queue):
        super(Consumer, self).__init__()
        self.queue = queue

def run(self):
    while True:
        time.sleep(0.1)
        recvData = self.queue.get()
        print(&apos;接受到另一进程传递的数据：%s&apos; % (recvData))
if __name__ == &apos;__main__&apos;:
    q = multiprocessing.Queue()
    p1 = Producer(q)
    c1 = Consumer(q)

    p1.start()
    c1.start()
    p1.join()
    c1.join()</code></pre><p>输出结果与队列相似，先传入的先传出，后传入的后传出。</p>
<h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。<br><img src="https://img-blog.csdnimg.cn/20190722145312246.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>每个进程至少有一个线程，即进程本身。进程可以启动多个线程。操作系统像并行“进程”一样执行这些线程。<br><img src="https://img-blog.csdnimg.cn/20190722145435412.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>线程和进程各自有什么区别和优劣呢？</strong><br>进程是资源分配的最小单位，线程是程序执行的最小单位。<br>进程有自己的独立地址空间。线程是共享进程中的数据的，使用相同的地址空间.<br>进程之间的通信需要以通信的方式（IPC)进行。线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，难点:处理好同步与互斥。</p>
<p><strong>线程分类</strong><br>有两种不同的线程：<br>内核线程<br>用户空间线程或用户线程<br>内核线程是操作系统的一部分，而内核中没有实现用户空间线程。</p>
<p><strong>多线程编程实现</strong><br>python的thread模块是⽐较底层的模块，python的threading 模块是对thread做了⼀些包装的，可以更加⽅便的被使⽤<br><img src="https://img-blog.csdnimg.cn/20190722145743512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>方法分析</strong><br>多线程程序的执⾏顺序是不确定的。<br>当执⾏到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进⼊就绪（Runnable）状态，等待调度。⽽线程调度将⾃⾏选择⼀个线程执⾏。<br>代码中只能保证每个线程都运⾏完整个run函数，但是线程的启动顺序、 run函数中每次循环的执⾏顺序都不能确定。</p>
<p><img src="https://img-blog.csdnimg.cn/20190722145910769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="项目案例-IP地址归属地批量查询任务"><a href="#项目案例-IP地址归属地批量查询任务" class="headerlink" title="项目案例: IP地址归属地批量查询任务"></a>项目案例: IP地址归属地批量查询任务</h2><p><strong>地址处于活动状态或哪些计算机处于活动状态，则可以使用此脚本。我们将依次ping地址, 每次都要等几秒钟才能返回值。这可以在Python中编程，在IP地址的地址范围内有一个for循环和一个os.popen（“ping -q -c2”+ ip）。</strong> </p>
<p><strong>项目瓶颈: 没有线程的解决方案效率非常低，因为脚本必须等待每次ping。</strong> </p>
<p>非多线程版本代码：</p>
<pre><code>import json
import requests
import pymysql

conn = pymysql.connect(host=&apos;172.25.254.149&apos;, user=&apos;root&apos;, password=&apos;990038&apos;, db=&apos;mysql&apos;)
#连接数据库
cursor = conn.cursor()
#设置邮标
# create_sqli = &apos;create table IP(ipid varchar(20),ipcity varchar(20),ipcountry varchar(20));&apos;(数据库建表操作，如果已经存在这一步便没有必要重复进行)
# cursor.execute(create_sqli)


def get_addr(ip):
    url = &apos;http://ip-api.com/json/%s&apos; % (ip)
    #从上面这个网址获取各ip所在地址
    count = requests.get(url).text
    dict_data = json.loads(count)
    city = dict_data.get(&apos;city&apos;)
    country = dict_data.get(&apos;country&apos;)
    #获取到所在城市以及国家的信息
    insert_sqli = &apos;insert into IP(ipid,ipcity,ipcountry) values(&quot;%s&quot;, &quot;%s&quot;, &quot;%s&quot;);&apos; %(ip, city, country)
    #将获取到的信息导入数据库
    print(insert_sqli)
    #将结果打印出来确定是否导入
    cursor.execute(insert_sqli)
    conn.commit()
    # print(&quot;&quot;&quot;
    # %s
    # 所在城市：%s
    # 所在国家：%s
    #
    # &quot;&quot;&quot; % (ip,dict_data[&apos;city&apos;],dict_data[&apos;country&apos;]))


if __name__ == &apos;__main__&apos;:
    for i in range(25):
        ip = str(&apos;1.1.1.&apos;) + str(1 + i)
        get_addr(ip)
        #将1.1.1.1到1.1.1.255的ip信息全部获取并且存入
    cursor.close()
    conn.close()</code></pre><p>多线程版本代码(使用sqlalchemy)：</p>
<pre><code>import requests
import json
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from threading import Thread


def task(ip):
    &quot;&quot;&quot;获取指定IP的所在城市和国家并存储到数据库中&quot;&quot;&quot;
    # 获取网址的返回内容
    url = &apos;http://ip-api.com/json/%s&apos; % (ip)
    try:
        response = requests.get(url)
    except Exception as e:
        print(&quot;网页获取错误:&quot;, e)
    else:
        # 默认返回的是字符串
        &quot;&quot;&quot;
        {&quot;as&quot;:&quot;AS174 Cogent Communications&quot;,&quot;city&quot;:&quot;Beijing&quot;,&quot;country&quot;:&quot;China&quot;,&quot;countryCode&quot;:&quot;CN&quot;,&quot;isp&quot;:&quot;China Unicom Shandong Province network&quot;,&quot;lat&quot;:39.9042,&quot;lon&quot;:116.407,&quot;org&quot;:&quot;NanJing XinFeng Information Technologies, Inc.&quot;,&quot;query&quot;:&quot;114.114.114.114&quot;,&quot;region&quot;:&quot;BJ&quot;,&quot;regionName&quot;:&quot;Beijing&quot;,&quot;status&quot;:&quot;success&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;zip&quot;:&quot;&quot;}
        &quot;&quot;&quot;
        contentPage = response.text
        # 将页面的json字符串转换成便于处理的字典;
        data_dict = json.loads(contentPage)
        # 获取对应的城市和国家
        city = data_dict.get(&apos;city&apos;, &apos;null&apos;)  # None
        country = data_dict.get(&apos;country&apos;, &apos;null&apos;)

        print(ip, city, country)
        # 存储到数据库表中ips
        ipObj = IP(ip=ip, city=city, country=country)
        session.add(ipObj)
        session.commit()


if __name__ == &apos;__main__&apos;:
    engine = create_engine(&quot;mysql+pymysql://root:westos@172.25.254.123/pymysql&quot;,
                           encoding=&apos;utf8&apos;,
                           # echo=True
                           )
    # 创建缓存对象
    Session = sessionmaker(bind=engine)
    session = Session()

# 声明基类
Base = declarative_base()


class IP(Base):
    __tablename__ = &apos;ips&apos;
    id = Column(Integer, primary_key=True, autoincrement=True)
    ip = Column(String(20), nullable=False)
    city = Column(String(30))
    country = Column(String(30))

    def __repr__(self):
        return self.ip


# 创建数据表
Base.metadata.create_all(engine)

# 1.1.1.1 -- 1.1.1.10
threads = []
for item in range(10):
    ip = &apos;1.1.1.&apos; + str(item + 1)  # 1.1.1.1 -1.1.1.10
    # task(ip)
    # 多线程执行任务
    thread = Thread(target=task, args=(ip,))
    # 启动线程并执行任务
    thread.start()
    # 存储创建的所有线程对象;
    threads.append(thread)

[thread.join() for thread in threads]
print(&quot;任务执行结束.........&quot;)
print(session.query(IP).all())</code></pre><p><strong>共享全局变量</strong><br>优点: 在⼀个进程内的所有线程共享全局变量，能够在不使⽤其他⽅式的前提 下完成多线程之间的数据共享（这点要⽐多进程要好） </p>
<p>缺点: 线程是对全局变量随意遂改可能造成多线程之间对全局变量 的混乱（即线程⾮安全）</p>
<p><strong>享全局变量：如何解决线程不安全问题?</strong><br>GIL(global interpreter lock): python解释器中任意时刻都只有一个线程在执行;<br>Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。</p>
<p><img src="https://img-blog.csdnimg.cn/20190722152428455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190722152459624.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>线程同步：</strong><br>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作.<br><strong>同步就是协同步调，按预定的先后次序进⾏运⾏。如:你说完，我再说。 “同”字从字⾯上容易理解为⼀起动作 其实不是，”同”字应是指协同、协助、互相配合。</strong></p>
<p><strong>线程锁的代码实现。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190722153157151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>银行转账问题：</strong></p>
<pre><code>import threading


def add(lock):
    global money #声明money为全局变量
    for i in range(1000000):
        #2.操作变量之前进行加锁
        lock.acquire()
        money += 1
        lock.release()

def reduce(lock):
    global money
    for i in range(100000):
        #2.操作变量之前进行加锁
        lock.acquire()
        money -= 1
        #3.操作变量之后进行解锁
        lock.release()
if __name__ == &apos;__main__&apos;:
    money = 0
    #1.实例化一个锁对象
    lock = threading.Lock()
    t1 = threading.Thread(target=add,args=(lock,))
    t2 = threading.Thread(target=reduce,args=(lock,))
    t1.start()
    t2.start()
    t1.join()
    t2.join()
    print(&apos;当前金额：&apos;,money)</code></pre><p><strong>死锁</strong><br>在线程间共享多个资源的时候，如果两个线程分别占有⼀部分资源并且同时 等待对⽅的资源，就会造成死锁。<br><img src="https://img-blog.csdnimg.cn/20190722154356995.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190722154420130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>协程，又称微线程，纤程。英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</strong><br><img src="https://img-blog.csdnimg.cn/20190722154527346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>协程优势</strong><br>    执行效率极高,因为子程序切换(函数)不是线程切换,由程序自身控制,<br>    没有切换线程的开销。所以与多线程相比,线程的数量越多,协程性能的优势越明显。<br>    不需要多线程的锁机制,因为只有一个线程,也不存在同时写变量冲突,在控制共享资源时也不需要加锁,因此执行效率高很多。</p>
<p><strong>实现协程的方法一（yield方法）：</strong><br><img src="https://img-blog.csdnimg.cn/2019072215475599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190722154819919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>基本思想：<br>当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。<br><img src="https://img-blog.csdnimg.cn/20190722155133261.png" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img-blog.csdnimg.cn/20190722155226232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>线程与进程的区别？<br>答：进程为正在运行着的代码，除此之外还有需要运行的环境等。线程是操作系统能够运行的最小单位，他被包含在进程之中是进程中的实际运作单位。</li>
<li>进程间内存是否共享？如何实现通讯？<br>答：可以共享，可以通过进程池以及消息队列的方式进行内存分配。通过消息队列进行通讯，目的为数据传输，共享数据，通知事件，资源共享以及进程控制</li>
<li>进程间通信的方式？<br>答：linux系统进程间的通信方式有管道，信号，消息队列，以及套间字</li>
<li>多线程有几种实现方法，都是什么？<br>答：分别是实例化对象方法，以及创建子类方法。</li>
<li>GIL锁是怎么回事?<br>答：当存在全局变量时，每一个线程都要对全局变量进行修改改或者更新时，就还出现错误，所以python中就设置有GIL锁，使得在修改全局变量时只能一个线程能对其进行操作，当一个线程运行完后，下一个线程才能对其进行操作。</li>
<li>python中是否线程安全？如何解决线程安全？<br>答：Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。</li>
<li>什么叫死锁？<br>答：在线程间共享多个资源的时候，如果两个线程分别占有⼀部分资源并且同时 等待对⽅的资源，就会造成死锁。</li>
<li>什么是协程？常用的协程模块有哪些？</li>
<li>协程中的join是用来做什么用的？它是如何发挥作用的？</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/多任务编程/" data-id="cjyigf8w40009pb5edqla0bbv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-aa" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/aa/" class="article-date">
  <time datetime="2019-07-24T09:26:59.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/aa/">aa</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>aa</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/aa/" data-id="cjyigf8vz0006pb5ehesom3ga" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/hello-world/" class="article-date">
  <time datetime="2019-07-24T08:43:00.635Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/hello-world/" data-id="cjyigf8we000dpb5eeueah4t0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/25/Python函数/">Python函数</a>
          </li>
        
          <li>
            <a href="/2019/07/25/Python文件处理/">Python文件处理</a>
          </li>
        
          <li>
            <a href="/2019/07/25/Python高级特性/">Python高级特性</a>
          </li>
        
          <li>
            <a href="/2019/07/25/Python异常处理/">Python异常处理</a>
          </li>
        
          <li>
            <a href="/2019/07/25/Python垃圾回收机制/">Python垃圾回收机制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 赵子乔<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>