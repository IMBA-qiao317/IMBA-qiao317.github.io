<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>多任务编程 | 钢棍乔师傅的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="@[toc] 多任务编程现实生活中的多任务：有很多的场景中的事情是同时进行的，比如开车的时候，手和脚共同来驾驶汽车。再比如唱歌和跳舞也是同时进行的。 什么叫”多任务”？就是操作系统可以同时运行多个人物。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有三个任务正在进行。还有很多任务悄悄的正在后台同时运行着，只是桌面上没有现实而已。 单核CPU如何实现”">
<meta property="og:type" content="article">
<meta property="og:title" content="多任务编程">
<meta property="og:url" content="http://yoursite.com/2019/07/24/多任务编程/index.html">
<meta property="og:site_name" content="钢棍乔师傅的个人博客">
<meta property="og:description" content="@[toc] 多任务编程现实生活中的多任务：有很多的场景中的事情是同时进行的，比如开车的时候，手和脚共同来驾驶汽车。再比如唱歌和跳舞也是同时进行的。 什么叫”多任务”？就是操作系统可以同时运行多个人物。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有三个任务正在进行。还有很多任务悄悄的正在后台同时运行着，只是桌面上没有现实而已。 单核CPU如何实现”">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722101341379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722105118297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722110156741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722110410416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/201907221159147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722134319851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722141727156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722141959367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722145312246.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722145435412.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722145743512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722145910769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722152428455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722152459624.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722153157151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722154356995.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722154420130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722154527346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019072215475599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722154819919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722155133261.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190722155226232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2019-07-24T09:34:13.485Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多任务编程">
<meta name="twitter:description" content="@[toc] 多任务编程现实生活中的多任务：有很多的场景中的事情是同时进行的，比如开车的时候，手和脚共同来驾驶汽车。再比如唱歌和跳舞也是同时进行的。 什么叫”多任务”？就是操作系统可以同时运行多个人物。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有三个任务正在进行。还有很多任务悄悄的正在后台同时运行着，只是桌面上没有现实而已。 单核CPU如何实现”">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190722101341379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70">
  
    <link rel="alternate" href="/atom.xml" title="钢棍乔师傅的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">钢棍乔师傅的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Python开发与人工智能</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-多任务编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/多任务编程/" class="article-date">
  <time datetime="2019-07-24T09:33:39.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      多任务编程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="多任务编程"><a href="#多任务编程" class="headerlink" title="多任务编程"></a>多任务编程</h2><p>现实生活中的多任务：<br>有很多的场景中的事情是同时进行的，比如开车的时候，手和脚共同来驾驶汽车。再比如唱歌和跳舞也是同时进行的。</p>
<p><strong>什么叫”多任务”？</strong><br>就是操作系统可以同时运行多个人物。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有三个任务正在进行。还有很多任务悄悄的正在后台同时运行着，只是桌面上没有现实而已。</p>
<p><strong>单核CPU如何实现”多任务”呢？</strong><br>操作系统轮流让各个任务交替执行，每个任务执行0.01秒，这样反复执行下去。表面上看，每个任务交替执行，但CPU的执行速度实在是太快了，感觉就像所有任务都在同时执行一样。<br><img src="https://img-blog.csdnimg.cn/20190722101341379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>多核CPU如何实现”多任务”呢?</strong></p>
<p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多与CPU的核心数量，所以操作系统也会自动把很多任务轮流调度到每个核心上执行。<br><img src="https://img-blog.csdnimg.cn/20190722105118297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>编写完毕的代码，在没有运行的时候，称之为<strong>程序</strong>。<br>正在运行着的代码，就成为<strong>进程</strong>。<br><strong>注意</strong>：进程，除了包含代码以外，还需要运行的环境等，所以和程序是由区别的</p>
<p><img src="https://img-blog.csdnimg.cn/20190722110156741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>创建子进程</strong><br>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：<br><img src="https://img-blog.csdnimg.cn/20190722110410416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Python中创建子进程的常用函数：</p>
<pre><code>&quot;&quot;&quot;
os.fork()
os.getpid()   #获取当前进程的pid (process id)
os.getppid()    #获取当前进程的父进程pid(parent process id)
&quot;&quot;&quot;
import os
print(&quot;当前进程(pid = %d)正在运行......&quot; %(os.getpid()))
#在pycharm编写代码，程序的父进程就是pycharm；
print(&quot;当前进程的父进程为(pid=%d)正在运行.....&quot; %(os.getppid()))
print(&quot;开始创建子进程.....&quot;)

pid = os.fork()
if pid == 0;
    print(&apos;这是子进程返回的是0，子进程的pid为%d,父进程为%d&apos; %(os.getpid(),os.getppid()))
else:
    pring(&quot;这是父进程返回的，返回值为子进程的pid，为%d&quot; %(pid))</code></pre><p><strong>fork函数的作用：</strong><br>1.执行到os.fork()时，操作系统会创建一个新的进程复制父进程的所有信息到子进程中。<br>2.普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次。<br>3.父进程和子进程都会从fork()函数中得到一个返回值，子进程返回的是0，而父进程中返回子进程的id号。</p>
<p><strong>多进程修改全局变量</strong><br>多进程中，每个进程中所有数据(包括全局变量)都各拥有一份，互不影响。</p>
<p>由于Windows没有fork调用，由于Python是跨平台的，multiprocessing模块就是跨平台版本的多进程模块。multiprocessing模块提供了一个Processing模块提供了一个Process类来代表一个进程对象。</p>
<p>Process([group [, target [, name [, args [, kwargs]]]]])<br>    target：表示这个进程实例所调⽤对象；<br>    args：表示调⽤对象的位置参数元组；<br>    kwargs：表示调⽤对象的关键字参数字典；<br>    name：为当前进程实例的别名；<br>    group：⼤多数情况下⽤不到；<br>    Process类常⽤⽅法：<br>    is_alive()：    判断进程实例是否还在执⾏；<br>    join([timeout])：    是否等待进程实例执⾏结束，或等待多少秒；<br>    start()：        启动进程实例（创建⼦进程）；<br>    run()：        如果没有给定target参数，对这个对象调⽤start()⽅法时，就将执 ⾏对象中的run()⽅法；<br>    terminate()：    不管任务是否完成，⽴即终⽌；</p>
<p><strong>Process类常⽤属性</strong>：<br>    name：当前进程实例别名，默认Process-N，N为从1开始计数；<br>    pid：当前进程实例的PID值；</p>
<p><strong>多进程编程方法一：实例化对象</strong></p>
<pre><code>from multiprocessing import Process
for i in range(len(expression_list)):
    p = Process(target=eval_formula,args=(expression_list[i],))
    p.start()
    p.join()
def eval_formula(formula):</code></pre><p>示例1：</p>
<pre><code>from multiprocessing import Process
import time
def task1(): #定义第一个任务
    print(&apos;正在听音乐&apos;)
    time.sleep(1) #运行过后休眠1s
def task2(): #定义第二个任务
    print(&apos;正在编程。。。。&apos;)
    time.sleep(0.5) #运行完成休眠0.5s
def no_multi(): #不使用多进程编程运行的方法
    for i in range(2):
        task1()
    for i in range(5):
        task2()
def use_multi(): #使用多进程编程使程序运行
    processes = [] #创建一个列表，将运行次每次任务的过程存入列表
    for i in range(2):
        p = Process(target=task1,)
        p.start()
        processes.append(p)
    for i in range(5):
        p = Process(target=task2)
        p.start()
        processes.append(p)
    [process.join() for process in processes] #使前两个函数任务阻塞，运行完后方可运行主函数(当需要计算函数运行时间的时候需要用)
if __name__ == &apos;__main__&apos;:
    start_time = time.time()
    use_multi() #调用多进程方法，查看多进程运行所需时间
    end_time = time.time()
print(end_time-start_time)</code></pre><p><img src="https://img-blog.csdnimg.cn/201907221159147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以上为多进程编程运行所需要的时间，如果单进程的话时间应该为2<em>1+5</em>0.5=4.5s</p>
<p><strong>多进程编程方法2</strong></p>
<p>改写run函数：</p>
<p><img src="https://img-blog.csdnimg.cn/20190722134319851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><p><strong>为什么需要进程池Pool？</strong><br>当被操作对象数目不大时，可以直接利用multiprocessing中的Process动态成生多个进程，十几个还好，但如果是上百个，上千个目标，手动的去限制进程数量却又太过繁琐，此时可以发挥进程池的功效。</p>
<p>Pool可以提供指定数量的进程供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来它。</p>
<p><strong>进程池实现1：</strong></p>
<pre><code>import multiprocessing
p = multiprocessing.Pool(multiprocessing.cpu_count())
result = p.map(ecal_formula,expression_list)
p.close()
p.join()

def eval_formual(formula):
    #evalueates the expression</code></pre><p><strong>进程池实现2：</strong></p>
<pre><code>import multiprocessing
def job(id):

    print(&quot;start %d....&quot; % (id))

    print(&quot;end %d....&quot; % (id))
# 创建进程池对象
pool = multiprocessing.Pool(processes=4)
# 给进程池分配任务;
for i in range(10):
    pool.apply_async(job, args=(i + 1,))
pool.close()
# 等待所有的子进程执行结束， 关闭进程池对象;
pool.join()
print(&quot;所有任务执行结束.....&quot;)</code></pre><p><strong>进程池实现3：</strong></p>
<pre><code>from concurrent.futures import ProcessPoolExecutor
def job(id):
    print(&apos;start %d...&apos; % (id)&apos;)
    print(&quot;end %d...&quot; % (id))
pool = ProcessPoolExecutor(max_workers = 4)
#
#for id in ranger(10):
#    #分配任务给子进程，并且返回一个Future对象；
#         f1 = pool.submit(job,args=(id))
#     #判断子进程是否执行结束
#        print(f1.done())
#    #查看该子进程执行的结果
#        print(f1,range(10))</code></pre><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><strong>为什么需要进程之间的通信？</strong><br><img src="https://img-blog.csdnimg.cn/20190722141727156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>如何实现进程间的通信？</strong><br><img src="https://img-blog.csdnimg.cn/20190722141959367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>消息队列</strong><br>可以使⽤multiprocessing模块的Queue实现多进程之间的数据传递，<strong>Queue 本身是⼀个消息列队程序。</strong><br>Queue.qsize()：    返回当前队列包含的消息数量；<br>Queue.empty()：    如果队列为空，返回True，反之False ；<br>Queue.full()：    如果队列满了，返回True,反之False；<br>Queue.get([block[, timeout]])：<br>    获取队列中的⼀条消息，然后将其从列队中移除，block默认值为True；<br>Queue.get_nowait()：<br>    相当Queue.get(False)；<br>Queue.put(item,[block[, timeout]])：<br>    将item消息写⼊队列，block默认值 为True；<br>Queue.put_nowait(item)：<br>    相当Queue.put(item, False)</p>
<p><strong>消息队列实例：</strong></p>
<pre><code>import time</code></pre><p>import multiprocessing</p>
<p>class Producer(multiprocessing.Process):<br>    def <strong>init</strong>(self, queue):<br>        super(Producer, self).<strong>init</strong>()<br>        self.queue = queue</p>
<pre><code>def run(self):
    for i in range(10):
        self.queue.put(i)
        time.sleep(0.1)
        print(&apos;传递信息，内容为%s&apos; % (i))


class Consumer(multiprocessing.Process):
    def __init__(self, queue):
        super(Consumer, self).__init__()
        self.queue = queue

def run(self):
    while True:
        time.sleep(0.1)
        recvData = self.queue.get()
        print(&apos;接受到另一进程传递的数据：%s&apos; % (recvData))
if __name__ == &apos;__main__&apos;:
    q = multiprocessing.Queue()
    p1 = Producer(q)
    c1 = Consumer(q)

    p1.start()
    c1.start()
    p1.join()
    c1.join()</code></pre><p>输出结果与队列相似，先传入的先传出，后传入的后传出。</p>
<h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。<br><img src="https://img-blog.csdnimg.cn/20190722145312246.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>每个进程至少有一个线程，即进程本身。进程可以启动多个线程。操作系统像并行“进程”一样执行这些线程。<br><img src="https://img-blog.csdnimg.cn/20190722145435412.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>线程和进程各自有什么区别和优劣呢？</strong><br>进程是资源分配的最小单位，线程是程序执行的最小单位。<br>进程有自己的独立地址空间。线程是共享进程中的数据的，使用相同的地址空间.<br>进程之间的通信需要以通信的方式（IPC)进行。线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，难点:处理好同步与互斥。</p>
<p><strong>线程分类</strong><br>有两种不同的线程：<br>内核线程<br>用户空间线程或用户线程<br>内核线程是操作系统的一部分，而内核中没有实现用户空间线程。</p>
<p><strong>多线程编程实现</strong><br>python的thread模块是⽐较底层的模块，python的threading 模块是对thread做了⼀些包装的，可以更加⽅便的被使⽤<br><img src="https://img-blog.csdnimg.cn/20190722145743512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>方法分析</strong><br>多线程程序的执⾏顺序是不确定的。<br>当执⾏到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进⼊就绪（Runnable）状态，等待调度。⽽线程调度将⾃⾏选择⼀个线程执⾏。<br>代码中只能保证每个线程都运⾏完整个run函数，但是线程的启动顺序、 run函数中每次循环的执⾏顺序都不能确定。</p>
<p><img src="https://img-blog.csdnimg.cn/20190722145910769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="项目案例-IP地址归属地批量查询任务"><a href="#项目案例-IP地址归属地批量查询任务" class="headerlink" title="项目案例: IP地址归属地批量查询任务"></a>项目案例: IP地址归属地批量查询任务</h2><p><strong>地址处于活动状态或哪些计算机处于活动状态，则可以使用此脚本。我们将依次ping地址, 每次都要等几秒钟才能返回值。这可以在Python中编程，在IP地址的地址范围内有一个for循环和一个os.popen（“ping -q -c2”+ ip）。</strong> </p>
<p><strong>项目瓶颈: 没有线程的解决方案效率非常低，因为脚本必须等待每次ping。</strong> </p>
<p>非多线程版本代码：</p>
<pre><code>import json
import requests
import pymysql

conn = pymysql.connect(host=&apos;172.25.254.149&apos;, user=&apos;root&apos;, password=&apos;990038&apos;, db=&apos;mysql&apos;)
#连接数据库
cursor = conn.cursor()
#设置邮标
# create_sqli = &apos;create table IP(ipid varchar(20),ipcity varchar(20),ipcountry varchar(20));&apos;(数据库建表操作，如果已经存在这一步便没有必要重复进行)
# cursor.execute(create_sqli)


def get_addr(ip):
    url = &apos;http://ip-api.com/json/%s&apos; % (ip)
    #从上面这个网址获取各ip所在地址
    count = requests.get(url).text
    dict_data = json.loads(count)
    city = dict_data.get(&apos;city&apos;)
    country = dict_data.get(&apos;country&apos;)
    #获取到所在城市以及国家的信息
    insert_sqli = &apos;insert into IP(ipid,ipcity,ipcountry) values(&quot;%s&quot;, &quot;%s&quot;, &quot;%s&quot;);&apos; %(ip, city, country)
    #将获取到的信息导入数据库
    print(insert_sqli)
    #将结果打印出来确定是否导入
    cursor.execute(insert_sqli)
    conn.commit()
    # print(&quot;&quot;&quot;
    # %s
    # 所在城市：%s
    # 所在国家：%s
    #
    # &quot;&quot;&quot; % (ip,dict_data[&apos;city&apos;],dict_data[&apos;country&apos;]))


if __name__ == &apos;__main__&apos;:
    for i in range(25):
        ip = str(&apos;1.1.1.&apos;) + str(1 + i)
        get_addr(ip)
        #将1.1.1.1到1.1.1.255的ip信息全部获取并且存入
    cursor.close()
    conn.close()</code></pre><p>多线程版本代码(使用sqlalchemy)：</p>
<pre><code>import requests
import json
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from threading import Thread


def task(ip):
    &quot;&quot;&quot;获取指定IP的所在城市和国家并存储到数据库中&quot;&quot;&quot;
    # 获取网址的返回内容
    url = &apos;http://ip-api.com/json/%s&apos; % (ip)
    try:
        response = requests.get(url)
    except Exception as e:
        print(&quot;网页获取错误:&quot;, e)
    else:
        # 默认返回的是字符串
        &quot;&quot;&quot;
        {&quot;as&quot;:&quot;AS174 Cogent Communications&quot;,&quot;city&quot;:&quot;Beijing&quot;,&quot;country&quot;:&quot;China&quot;,&quot;countryCode&quot;:&quot;CN&quot;,&quot;isp&quot;:&quot;China Unicom Shandong Province network&quot;,&quot;lat&quot;:39.9042,&quot;lon&quot;:116.407,&quot;org&quot;:&quot;NanJing XinFeng Information Technologies, Inc.&quot;,&quot;query&quot;:&quot;114.114.114.114&quot;,&quot;region&quot;:&quot;BJ&quot;,&quot;regionName&quot;:&quot;Beijing&quot;,&quot;status&quot;:&quot;success&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;zip&quot;:&quot;&quot;}
        &quot;&quot;&quot;
        contentPage = response.text
        # 将页面的json字符串转换成便于处理的字典;
        data_dict = json.loads(contentPage)
        # 获取对应的城市和国家
        city = data_dict.get(&apos;city&apos;, &apos;null&apos;)  # None
        country = data_dict.get(&apos;country&apos;, &apos;null&apos;)

        print(ip, city, country)
        # 存储到数据库表中ips
        ipObj = IP(ip=ip, city=city, country=country)
        session.add(ipObj)
        session.commit()


if __name__ == &apos;__main__&apos;:
    engine = create_engine(&quot;mysql+pymysql://root:westos@172.25.254.123/pymysql&quot;,
                           encoding=&apos;utf8&apos;,
                           # echo=True
                           )
    # 创建缓存对象
    Session = sessionmaker(bind=engine)
    session = Session()

# 声明基类
Base = declarative_base()


class IP(Base):
    __tablename__ = &apos;ips&apos;
    id = Column(Integer, primary_key=True, autoincrement=True)
    ip = Column(String(20), nullable=False)
    city = Column(String(30))
    country = Column(String(30))

    def __repr__(self):
        return self.ip


# 创建数据表
Base.metadata.create_all(engine)

# 1.1.1.1 -- 1.1.1.10
threads = []
for item in range(10):
    ip = &apos;1.1.1.&apos; + str(item + 1)  # 1.1.1.1 -1.1.1.10
    # task(ip)
    # 多线程执行任务
    thread = Thread(target=task, args=(ip,))
    # 启动线程并执行任务
    thread.start()
    # 存储创建的所有线程对象;
    threads.append(thread)

[thread.join() for thread in threads]
print(&quot;任务执行结束.........&quot;)
print(session.query(IP).all())</code></pre><p><strong>共享全局变量</strong><br>优点: 在⼀个进程内的所有线程共享全局变量，能够在不使⽤其他⽅式的前提 下完成多线程之间的数据共享（这点要⽐多进程要好） </p>
<p>缺点: 线程是对全局变量随意遂改可能造成多线程之间对全局变量 的混乱（即线程⾮安全）</p>
<p><strong>享全局变量：如何解决线程不安全问题?</strong><br>GIL(global interpreter lock): python解释器中任意时刻都只有一个线程在执行;<br>Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。</p>
<p><img src="https://img-blog.csdnimg.cn/20190722152428455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190722152459624.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>线程同步：</strong><br>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作.<br><strong>同步就是协同步调，按预定的先后次序进⾏运⾏。如:你说完，我再说。 “同”字从字⾯上容易理解为⼀起动作 其实不是，”同”字应是指协同、协助、互相配合。</strong></p>
<p><strong>线程锁的代码实现。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190722153157151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>银行转账问题：</strong></p>
<pre><code>import threading


def add(lock):
    global money #声明money为全局变量
    for i in range(1000000):
        #2.操作变量之前进行加锁
        lock.acquire()
        money += 1
        lock.release()

def reduce(lock):
    global money
    for i in range(100000):
        #2.操作变量之前进行加锁
        lock.acquire()
        money -= 1
        #3.操作变量之后进行解锁
        lock.release()
if __name__ == &apos;__main__&apos;:
    money = 0
    #1.实例化一个锁对象
    lock = threading.Lock()
    t1 = threading.Thread(target=add,args=(lock,))
    t2 = threading.Thread(target=reduce,args=(lock,))
    t1.start()
    t2.start()
    t1.join()
    t2.join()
    print(&apos;当前金额：&apos;,money)</code></pre><p><strong>死锁</strong><br>在线程间共享多个资源的时候，如果两个线程分别占有⼀部分资源并且同时 等待对⽅的资源，就会造成死锁。<br><img src="https://img-blog.csdnimg.cn/20190722154356995.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190722154420130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>协程，又称微线程，纤程。英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</strong><br><img src="https://img-blog.csdnimg.cn/20190722154527346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>协程优势</strong><br>    执行效率极高,因为子程序切换(函数)不是线程切换,由程序自身控制,<br>    没有切换线程的开销。所以与多线程相比,线程的数量越多,协程性能的优势越明显。<br>    不需要多线程的锁机制,因为只有一个线程,也不存在同时写变量冲突,在控制共享资源时也不需要加锁,因此执行效率高很多。</p>
<p><strong>实现协程的方法一（yield方法）：</strong><br><img src="https://img-blog.csdnimg.cn/2019072215475599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190722154819919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>基本思想：<br>当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。<br><img src="https://img-blog.csdnimg.cn/20190722155133261.png" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img-blog.csdnimg.cn/20190722155226232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>线程与进程的区别？<br>答：进程为正在运行着的代码，除此之外还有需要运行的环境等。线程是操作系统能够运行的最小单位，他被包含在进程之中是进程中的实际运作单位。</li>
<li>进程间内存是否共享？如何实现通讯？<br>答：可以共享，可以通过进程池以及消息队列的方式进行内存分配。通过消息队列进行通讯，目的为数据传输，共享数据，通知事件，资源共享以及进程控制</li>
<li>进程间通信的方式？<br>答：linux系统进程间的通信方式有管道，信号，消息队列，以及套间字</li>
<li>多线程有几种实现方法，都是什么？<br>答：分别是实例化对象方法，以及创建子类方法。</li>
<li>GIL锁是怎么回事?<br>答：当存在全局变量时，每一个线程都要对全局变量进行修改改或者更新时，就还出现错误，所以python中就设置有GIL锁，使得在修改全局变量时只能一个线程能对其进行操作，当一个线程运行完后，下一个线程才能对其进行操作。</li>
<li>python中是否线程安全？如何解决线程安全？<br>答：Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。</li>
<li>什么叫死锁？<br>答：在线程间共享多个资源的时候，如果两个线程分别占有⼀部分资源并且同时 等待对⽅的资源，就会造成死锁。</li>
<li>什么是协程？常用的协程模块有哪些？</li>
<li>协程中的join是用来做什么用的？它是如何发挥作用的？</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/多任务编程/" data-id="cjyh1yc6c0002n65ec32a7nc6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/07/24/aa/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">aa</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/24/多任务编程/">多任务编程</a>
          </li>
        
          <li>
            <a href="/2019/07/24/aa/">aa</a>
          </li>
        
          <li>
            <a href="/2019/07/24/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 赵子乔<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>