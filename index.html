<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>钢棍乔师傅的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学无止境...">
<meta property="og:type" content="website">
<meta property="og:title" content="钢棍乔师傅的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="钢棍乔师傅的个人博客">
<meta property="og:description" content="学无止境...">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="钢棍乔师傅的个人博客">
<meta name="twitter:description" content="学无止境...">
  
    <link rel="alternate" href="/atom.xml" title="钢棍乔师傅的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">钢棍乔师傅的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Python开发与人工智能</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Python函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/Python函数/" class="article-date">
  <time datetime="2019-07-25T05:44:56.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/Python函数/">Python函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>问题：我们为什么需要函数？</strong><br><strong>答：如果在开发程序时，需要某块代码多次，但是为了提高编写的效率，以及代码的重用，所以把具有独立功能的代码块组成一个个小模块，这就是函数</strong></p>
<p><strong>1.函数范例</strong></p>
<p>函数的定义与调用：<br><img src="https://img-blog.csdnimg.cn/20190523215759958.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2.空函数</strong><br>定义一个什么也不用做的空函数，可以用pass语句；pass可以用作占位符，当你还没想好接下来的代码怎么写时，可以先用pass让你的代码运行起来。<br><img src="https://img-blog.csdnimg.cn/20190523220147272.png" alt="在这里插入图片描述"><br><strong>3.函数返回值</strong><br>所谓“返回值”，就是程序中，函数完成一件事后函数得出的算式并且返回给调用者的结果，没有返回值，则默认为None。</p>
<h2 id="实例演示：函数的创建与调用——猜数字游戏"><a href="#实例演示：函数的创建与调用——猜数字游戏" class="headerlink" title="实例演示：函数的创建与调用——猜数字游戏"></a><strong>实例演示：函数的创建与调用——猜数字游戏</strong></h2><p><strong>输入第一行中给出两个不超过100的正整数，分别是系统产生的随机数、以及猜测的最大次数N。随后每行给出一个用户，直到出现负数为止。</strong><br><img src="https://img-blog.csdnimg.cn/20190524164322683.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190524164344262.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>4.函数的应用：打印图像以及数学运算</strong><br><img src="https://img-blog.csdnimg.cn/20190524164555268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">函数的图像表示结果：<br><img src="https://img-blog.csdnimg.cn/20190524165818471.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190524171048244.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>数学运算部分：<br><img src="https://img-blog.csdnimg.cn/20190524171301753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>运行结果：<img src="https://img-blog.csdnimg.cn/20190524172203654.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>6.函数的优势</strong><br>从理论上说，不用函数，也能够编程，我们在前面已经写了程序，就没有写函数，当然，用python的内建函数姑且不算了。现在之所以使用函数，主要是：</p>
<ol>
<li>降低编程的难度(分而治之的思想)</li>
<li>代码重用。避免了重复劳动，提供了工作效率。</li>
</ol>
<p><strong>7.函数的各种变量</strong><br>1）局部变量</p>
<p><img src="https://img-blog.csdnimg.cn/20190524172458456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.局部变量,就是在函数内部定义的变量。<br><strong>2.不同的函数,可以定义相同的名字的局部变量,但是各用个的不会产生影响。</strong><br>3.局部变量的作用,为了临时保存数据需要在函数中定义变量来进行存储,这就是它的作用。</p>
<p>2）全局变量<br><img src="https://img-blog.csdnimg.cn/20190524172845591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>如果一个变量,既能在一个函数中使用,也能在其他的函数中使用,这样的变量就是全局变量。</strong><br>全局变量能够在所有的函数中进行访问<br><strong>如果在函数中修改全局变量,那么就需要使用global进行声明,否则出错</strong><br>如果全局变量的名字和局部变量的名字相同,那么使用的是<strong>局部变量</strong>的</p>
<p><strong>问：不使用global声明全局变量时不能修改全局变量?</strong><br><strong>答：global的本质是声明可以修改全局变量的指向， 即变量可以指向新的数据。<br>1). 不可变类型的全局变量: 指向的数据不能修改, 不使用global时无法修改全局变量。<br>2). 可变类型的全局变量: 指向的数据可以修改, 不使用global时可以修改全局变量。</strong></p>
<p><strong>8.函数中的各种参数</strong><br>1）形参与实参：<br><img src="https://img-blog.csdnimg.cn/2019052417362217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>定义时小括号中的参数,用来接收参数用的,称为 “形参”<br>调用时小括号中的参数,用来传递给函数用的,称为 “实参“</p>
<p>2）默认参数<br>需求: 定义一函数，计算x值的n次方。那如果计算x平方时只需要传入x值时怎么解决?<br><strong>默认参数可以降低调用函数的难度。</strong><br>默认参数注意事项：<br>有多个参数时,变化大放前面,变化小的放后面；<br>必选参数在前,默认参数在后。<br><img src="https://img-blog.csdnimg.cn/20190524174250248.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3）可变参数<br>可变参数就是传入的参数个数是可变的,可以是 1 个、2 个到任意个,还可以是 0 个。<br><img src="https://img-blog.csdnimg.cn/20190524175000657.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如果已经有一个 list 或者 tuple,要调用一个可变参数怎么办?<br> Python 允许你在 list 或 tuple 前面加一个 * 号<br> 把 list 或 tuple 的元素变成可变参数传进去：</p>
<pre><code>largs = [1,2,3]
func(largs[0],largs[1],largs[2])
func(*largs)</code></pre><p> 4）关键字参数</p>
<p>关键字参数允许传入 0 个或任意个含参数名的参数;<br>这些关键字参数在函数内部自动组装为一个 dict;<br>关键字参数用**kwargs;<br><img src="https://img-blog.csdnimg.cn/20190524180411420.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">5）参数组合<br>参数组合是指可以必选参数、 默认参数、 可变参数和关键字参数一起使用。<br>参数定义的顺序必须是:必选参数、 默认参数、可变参数和关键字参数。</p>
<p><strong>参数总结</strong><br><img src="https://img-blog.csdnimg.cn/20190524180611717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5-25-匿名函数"><a href="#5-25-匿名函数" class="headerlink" title="5.25 匿名函数"></a>5.25 匿名函数</h2><p><strong>1) 定义：</strong><br> 匿名函数指一类无需定义标识符的函数与子程序，Python用lambda语法定义匿名函数，只需要用表达式无需声明。（省略了用def声明函数的标准步骤。期间两个变量用冒号分隔。）<br> <img src="https://img-blog.csdnimg.cn/20190527094538353.png" alt="在这里插入图片描述"><br> 以上图片显示出的结果分别为：<br> 30，40</p>
<p><strong>lambda函数的语法只包含一个语句，如下：<img src="https://img-blog.csdnimg.cn/20190527094914928.png" alt="在这里插入图片描述"><br>lambda函数能接收任何数量的参数，但只能返回一个表达式的值。</strong></p>
<p><strong>2）应用实例：函数作为参数传递</strong><br><img src="https://img-blog.csdnimg.cn/20190527100143576.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>应用实例：作为内置函数的参数</strong></p>
<p> <img src="https://img-blog.csdnimg.cn/20190527100709419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20190527100726558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h1><p><strong>问题描述1： 有一个整数列表(若干个元素)， 要求调整元素顺序，把所有的奇数放在前面，偶数放在后面。</strong><br><img src="https://img-blog.csdnimg.cn/20190527102626596.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>**问题描述2：给定一个整形数组， 将数组中所有的0移动到末尾， 非0项保持不变；<br>在原始数组上进行移动操作， 勿创建新的数组;</p>
<p>#输入: 数组的记录;0 7 0 2</p>
<p>#输出: 调整后数组的内容; 7 2 0 0**<br><img src="https://img-blog.csdnimg.cn/20190527104208727.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p><strong>1.定义：</strong><br><strong>已知: 函数可以调用函数。结论: 一个函数在内部调用自己本身,这个函数就是递归数。<br>需求:<br>计算阶乘 factorial：  n! = 1 * 2 * 3 * … * n</strong></p>
<p><strong>什么是递归函数？</strong><br>1）阶乘的规律：<img src="https://img-blog.csdnimg.cn/20190527114759622.png" alt="在这里插入图片描述"><br>2）代码实现：<br><img src="https://img-blog.csdnimg.cn/20190527114836656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>练习：<img src="https://img-blog.csdnimg.cn/20190527115917451.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>递归函数思路：</strong><img src="https://img-blog.csdnimg.cn/20190528082417120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>递归函数模型：汉诺塔问题</strong><br><img src="https://img-blog.csdnimg.cn/20190528082502962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>n代表汉诺塔盘子的个数：<br>n=1，sum=1<em>（2*<em>1-1）<br>n=2，sum=3</em>（2</em> *2-1)<br>.<br>.<br>.</p>
<p>n=n，sum=2<em>n-1(2</em>n-1）</p>
<p><strong>解决方法图解：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190528083152321.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190528083200982.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190528083211712.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190528083224908.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190528083241729.png" alt="在这里插入图片描述"></p>
<h2 id="练习部分："><a href="#练习部分：" class="headerlink" title="练习部分："></a>练习部分：</h2><p><strong>1.编程实现 9*9乘法表(循环嵌套的复习)</strong></p>
<pre><code>a = 1
b = 1
print(&apos;%d* %d = %d\t&apos; % (a , b,a*b))
for item in range(8):
a += 1
print(&apos;%d* %d = %d\t&apos; % (a, b, a * b))
b += 1
print(&apos;%d* %d = %d\t&apos; % (a, b, a * b))</code></pre><p><strong>2. 用函数实现求100-200里面所有的素数。<br> 提示:素数的特征是除了1和其本身能被整除,其它数都不能被整除的数</strong></p>
<pre><code>def qiusushu():
list = []
for a in range(100, 200):
    for i in range(2, int(a-1)):
        list.append(int(a % i))
    if list.count(0) != 0:
        del list[:]
    else:
        print(a)
qiusushu()</code></pre><p><strong>3.用函数实现输入某年某月某日,判断这一天是这一年的第几天?闰年情况也考虑进去。</strong></p>
<pre><code>def runnian():
x = input(&quot;请输入的年份：&quot;)
y = input(&quot;请输入的月份：&quot;)
z = input(&quot;请输入的日期：&quot;)
li = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
if ((int(x) % 4 == 0) and (int(x) % 100 != 0)) or (int(x) % 400 == 0):
    days = 0
    for i in range(1, int(y)):
        days += li[i]
    if int(y) &gt;= 3:
        result = days + int(z) + 1
    else:
        result = days + int(z)
    print(result)
else:
    days = 0
    for i in range(1, int(y)):
        days += li[i]
    result = days + int(z)
    print(result)
runnian()</code></pre><p><strong>4.题目需求:对于一个十进制的正整数， 定义f(n)为其各位数字的平方和，如:<br>    f(13) = 1 ** 2 + 3 ** 2 = 10<br>    f(207) = 2 ** 2 + 0 ** 2 + 7 ** 2 = 53</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/Python函数/" data-id="cjyigf8vm0000pb5eportf04e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python文件处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/Python文件处理/" class="article-date">
  <time datetime="2019-07-25T05:41:03.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/Python文件处理/">Python文件处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="文件："><a href="#文件：" class="headerlink" title="文件："></a>文件：</h2><p><strong>文件操作介绍：</strong><br><strong>1.文件的作用：</strong><br>       一个程序在运行过程中用了九牛二虎之力终于计算出了结果,试想一下如果不把这些数据存放起来,相比重启电脑之后,“哭都没地方哭了”。 默认数据是加载到内存中，结果也是保存到内存中， 程序执行结束，所有的数据释放。</p>
<p><strong>2.文件的打开与关闭：</strong><br><img src="https://img-blog.csdnimg.cn/20190528084026918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>宋丹丹拉高音调说：这个得分成三步，第一步打开冰箱；第二步，把大象塞进冰箱里；第三步，把冰箱关上。在操作文件的整体过程与将大象放入冰箱的过程是很相似的。</p>
<p><strong>1）文件的打开：</strong><br>在python,使用open函数,可以打开一个已经存在的文件,或者创建一个新文件。<br>open(文件名,访问模式)   e.g. f = open(‘test.txt’, ‘w’)<br>如果文件不存在那么创建,如果存在那么就先清空,然后写入数据。<br><img src="https://img-blog.csdnimg.cn/20190528084915268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>r：只读<br>w：清空写入（不读）<br>a:追加写入（不读）<br>w+：读并且清空写入<br>r+：读且从文件开头写入<br>a+：读且从末尾追加写入</strong></p>
<p><strong>2）  File对象的属性</strong><br><img src="https://img-blog.csdnimg.cn/20190528085327133.png" alt="在这里插入图片描述"><strong>3）File对象的常用方法</strong><br><img src="https://img-blog.csdnimg.cn/2019052809083663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>seek(offset, from)有2个参数:<br>offset:偏移量<br>from:方向   0:表示文件开头; 1:表示当前位置; 2:表示文件末尾<br>练习：<br>1). 把位置设置为:从文件开头,偏移5个字节    seek（5，0）。<br>2). 把位置设置为:离文件末尾,3字节处   seek（-3，2）。（python3中无法完成）</p>
<p><strong>3) 文件的关闭</strong><br>方法一: 调用close() ：方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，<br>并且操作系统同一时间能打开的文件数量也是有限的：<br>方法二:  Python引入了with语句来自动帮我们调用close()方法：<br><img src="https://img-blog.csdnimg.cn/20190528093351605.png" alt="在这里插入图片描述"><br>with语句的工作原理：<br>python中的with语句使用于对资源进行访问的场合，保证不管处理过程中是否发生错误或者异常都会自动执行规定的(“清理”)操作，释放被访问的资源，比如有文件读写后自动关闭、线程中锁的自动获取和释放等。</p>
<p><strong>文件应用：文件的备份</strong><br>输入文件的名字,然后程序自动完成对文件进行备份。<br><img src="https://img-blog.csdnimg.cn/20190528094447726.png" alt="在这里插入图片描述"></p>
<h2 id="关于操作系统：OS"><a href="#关于操作系统：OS" class="headerlink" title="关于操作系统：OS"></a>关于操作系统：OS</h2><p><strong>os，语义为操作系统，处理操作系统相关的功能，可跨平台。 比如显示当前目录下所有文件/删除某个文件/获取文件大小……</strong><br><img src="https://img-blog.csdnimg.cn/20190528095426222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>关于路径：</strong><br><img src="https://img-blog.csdnimg.cn/20190528095506842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>os模块</strong><br>os模块中的rename()可以完成对文件的重命名操作。<br> rename(需要修改的文件名, 新的文件名)<br>os模块中的remove()可以完成对文件的删除操作<br> remove(待删除的文件名)<br> <strong>os模块的其他操作</strong><br> <img src="https://img-blog.csdnimg.cn/20190528114949254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="JSON-部分"><a href="#JSON-部分" class="headerlink" title="JSON    部分"></a>JSON    部分</h2><p> <strong>1.什么是json？</strong><br> JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。<br> JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯(包括C、C++、Java、JavaScript、Perl、Python等)。<br> 这些特性使JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。<br> <strong>2.python数据类型和json数据类型相互转换格式</strong><br> <img src="https://img-blog.csdnimg.cn/20190528120002368.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190528120013141.png" alt="在这里插入图片描述"><br><strong>python 中str类型到JSON中转为unicode类型，None转为null,dict对应object；<br>pyhton中的集合不能转成json格式。</strong></p>
<p><strong>3.数据类型编码</strong><br><img src="https://img-blog.csdnimg.cn/20190528131311743.png" alt="在这里插入图片描述"><br>dump:　　将对象序列化并保存到文件<br>load:　　  将序列化字符串从文件读取并反序列化</p>
<p>json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True,<br> allow_nan=True, cls=None, indent=None, separators=None,<br> encoding=”utf-8”, default=None, sort_keys=False, **kw)<br>  ensure_ascii=False: 中文存储需要设定<br> indent=4: 增加缩进，增强可读性，但缩进空格会使数据变大<br> separators=(‘,’,’:’): 自定义分隔符,元素间分隔符为逗号， 字典key和value值的分隔符为冒号<br> sort_keys=True: 字典排序</p>
<p><strong>4.序列化与反序列化参数</strong><br><img src="https://img-blog.csdnimg.cn/20190528131747203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Pickle模块详解"><a href="#Pickle模块详解" class="headerlink" title="Pickle模块详解"></a>Pickle模块详解</h2><p><strong>1.定义：</strong><br>python的pickle模块实现了python的所有数据序列和反序列化。与JSON不同的是pickle不是用于多种语言间的数据传输，它仅作为python对象的持久化或者python程序间进行互相传输对象的方法，因此它支持了python所有的数据类型。<br><img src="https://img-blog.csdnimg.cn/20190529084758725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2.pickle模块与json模块的区别</strong><br>1、JSON只能处理基本数据类型。pickle能处理所有Python的数据类型。<br>2、JSON用于各种语言之间的字符转换。pickle用于Python程序对象的持久化或者Python程序间对象网络传输，但不同版本的Python序列化可能还有差异。</p>
<h2 id="练习部分"><a href="#练习部分" class="headerlink" title="练习部分"></a>练习部分</h2><p><strong>1.读取一个文件,显示除了以井号(#)开头的行以外的所有行。</strong><br>练习结果：<img src="https://img-blog.csdnimg.cn/20190530173012718.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2.制作一个”密码薄”,其可以存储一个网址(例如 <a href="http://www.csdn.net),和一个密码" target="_blank" rel="noopener">www.csdn.net),和一个密码</a>(例如 123456),请编写程序完成这个“密码薄”的增删改查功能,并且实现文件存储功能。</strong><br>实验代码：</p>
<pre><code> import json

 dict = {}


 def mibaben():
    for i in range(1, 3):
        name = input(&quot;请输入网址：&quot;)
        passwd = input(&quot;该网址的密码为：&quot;)
        dict[name] = passwd
    a = json.dumps(dict, sort_keys=True)

    x = open(&apos;mimaben1.txt&apos;, &apos;w&apos;)
    x.writelines(a)
    x.close()


 def tianjia():
    dict.update({input(&quot;输入新网站：&quot;): input(&quot;输入新密码：&quot;)})
    a = json.dumps(dict, sort_keys=True)

    x = open(&apos;mimaben1.txt&apos;, &apos;a+&apos;)
    x.writelines(a)
    x.close()


 def shanchu():
    dict.pop(input(&quot;要删除的网址为：&quot;))
    a = json.dumps(dict, sort_keys=True)

    x = open(&apos;mimaben1.txt&apos;, &apos;a+&apos;)
    x.writelines(a)
    x.close()


mibaben()
if input() == &apos;xiugai&apos;:
    tianjia()
if input() == &quot;shanchu&quot;:
    shanchu()</code></pre><p><strong>3. 学生管理系统(文件版)<br>1). 必须使用自定义函数,完成对程序的模块化<br>2). 学生信息至少包含:姓名、年龄、学号,除此以外可以适当添加<br>3). 必须完成的功能:添加、删除、修改、查询、退出</strong></p>
<p><strong>4.无重复字符的最长子串longest-substring-without-repeating-characters</strong><br><img src="https://img-blog.csdnimg.cn/20190530173642678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码：</p>
<pre><code> def lengthOfLongestSubstring(s):
&quot;&quot;&quot;
:type s: str
:rtype: int
&quot;&quot;&quot;
# 存储历史循环中最长的子串长度
max_len = 0
# 判断传入的字符串是否为空
if s is None or len(s) == 0:
    return max_len
# 定义一个字典，存储不重复的字符和字符所在的下标
str_dict = {}
# 存储每次循环中最长的子串长度
one_max = 0
# 记录最近重复字符所在的位置+1
start = 0
for i in range(len(s)):
    # 判断当前字符是否在字典中和当前字符的下标是否大于等于最近重复字符的所在位置
    if s[i] in str_dict and str_dict[s[i]] &gt;= start:
        # 记录当前字符的值+1
        start = str_dict[s[i]] + 1
        # print start
    # 在此次循环中，最大的不重复子串的长度
    one_max = i - start + 1                 #pwwpss
    # 把当前位置覆盖字典中的位置
    str_dict[s[i]] = i
    # 比较此次循环的最大不重复子串长度和历史循环最大不重复子串长度
    max_len = max(max_len, one_max)
return max_len
print(lengthOfLongestSubstring(&apos;pwwssffasdf&apos;))</code></pre><p><strong>4.矩阵置零set-matrix-zeroes</strong><br><img src="https://img-blog.csdnimg.cn/20190530174357422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/Python文件处理/" data-id="cjyigf8xs000jpb5e5yialsyx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python高级特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/Python高级特性/" class="article-date">
  <time datetime="2019-07-25T05:39:56.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/Python高级特性/">Python高级特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="Python高级特性"><a href="#Python高级特性" class="headerlink" title="Python高级特性"></a>Python高级特性</h2><p><strong>1.列表生成式</strong><br>列表生成式就是一个用来生成列表的特定语法形式的表达式。<br>是Python提供的一种生成列表的简洁形式, 可快速生成一个新的list。<br>普通的语法格式：[exp for iter_var in iterable]<br>带过滤功能语法格式: [exp for iter_var in iterable if_exp]<br>循环嵌套语法格式: [exp for iter_var_A in iterable_A for iter_var_B in iterable_B]</p>
<p><strong>2.列表生成式实例</strong><br>1). 求1-50所有数的平方<br>square = [(i + 1) ** 2 for i in range(50)]<br>print(square)<br>2). 生成一个2n+1的数字列表，n为从3到11的数字。<br>nums_list = [2 * n + 1 for n in range(3, 12)]<br>print(nums_list)<br>3).  求以r为半径的圆的面积和周长(r的范围从1到10)。<br>import math<br>circle = [(math.pi * (r ** 2), 2 * math.pi * r) for r in range(1, 11)]<br>print(circle)</p>
<p><strong>3.集合生成式与字典生成式</strong><br>1）集合生成式：用来快速生成集合。<br>2）字典生成式：用来快速生成字典。<br><img src="https://img-blog.csdnimg.cn/20190604102807960.png" alt="在这里插入图片描述"></p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p><strong>生成器：Python中一边循环，一边计算的机制，被称为生成器。</strong></p>
<p><strong>问：什么时候需要生成器？<br>答：一般情况下我们不需要使用生成器,只有当我们因为性能限制才需要用到,比如我们使用python读取一个10g的文件,如果一次性将10g的文件加载到内存处理的话(read方法),内存肯定会溢出;这里如果可以使用生成器把读写交叉处理进行,比如使用(readline和readlines)就可以再循环读取的同时不断处理,样就可以节省大量的内存空间。</strong></p>
<p><strong>1）如何创建生成器？</strong><br>第一种：列表生成式的改写。（将生成式中的【】改为（））<br>第二种：yield关键字。<br><strong>2）如何打印生成器的每个元素呢？</strong><br>通过for循环， 依次计算并生成每一个元素。<br>如果要一个一个打印出来,可以通过next()函数获得生成器的下一个返回值。<br><strong>3）生成器的特点：</strong><br>1.节约内存。2.迭代到下一次的调用时,所使用的参数都是第一次所保留下的,即是说,在整个所有函数调用的参数都是第一次所调用时保留的,而不是新创建的。</p>
<h2 id="生成器实例："><a href="#生成器实例：" class="headerlink" title="生成器实例："></a>生成器实例：</h2><p> <strong>1.斐波那契数列</strong>：<br>除第一个和第二个数外,任意一个数都可由前两个数相加得到.<br>1, 1, 2, 3, 5, 8, 13, 21, 34</p>
<pre><code> def fib(n):
# a代表第一个数， b代表第2个数， 也就是要显示的数; count: 当前已经显示fib数列的个数;当前为0;
a, b, count = 0, 1, 0
# 0&lt;5
while count &lt; n:
    # print(b)
    yield  b
    # a, b = b, a+b
    a, b = b, a+b
    # 已经显示的次数加1
    count += 1
# f是一个生成器(函数里面有yield)
f = fib(5)
while True:
    try:
        print(next(f))
    except:
        break</code></pre><p><strong>2.利用yield求平均值。</strong><br>     <img src="https://img-blog.csdnimg.cn/20190604113106297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>def averager():
    # 所有数的和, 默认为0；
    total = 0.0
    # 数值的个数;
    count = 0
    # 平均值结果;
    average = None
    # 所有数值存储的容器(List);
    all_items = []
    while True:
        # 函数包含yield关键字
        new_item = yield average, all_items
        all_items.append(int(new_item))
        total += new_item
        count += 1
        average = total / count
def main():
    # AVERAGER是个生成器;
    AVERAGER = averager()
    # 第一次调用next方法， 遇到yield停止，
    next(AVERAGER)
    # 死循环， 依次求解平均值;
    while True:
        new_num = input(&quot;请输入求平均值的数: &quot;)
        if new_num == &apos;q&apos;:
            print(&quot;程序执行结束.....&quot;)
            break
        # 1). 通过send方法将求平均值的数值传到yield所在位置,(14行);
        # 2). send方法的返回值是求平均值的列表和平均值结果;
        average, all_items = AVERAGER.send(int(new_num))
        print(all_items, &quot;的平均值为:&quot;, average)
main()</code></pre><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>什么是迭代器？</strong><br><strong>迭代是访问容器元素的一种方式。迭代器是一个可以记住遍历的位置的对象。<br>迭代器对象从集合的第一个元素开始访问,直到所有的元素被访问完结束。</strong></p>
<p><strong>可迭代对象：可以直接作用于for循环的对象(如何判断是否可以迭代?)<br>一类是集合数据类型,如list， tuple，dict， set，str等;<br>一类是generator,包括生成器和带yield的generator function。</strong></p>
<p><strong>迭代器特点：<br>（1）可以被next()函数调用并不断返回下一个值的对象称为迭代器:Iterator。<br>（2）生成器都是Iterator对象,但list、dict、str虽然是Iterable,却不是Iterator。<br>（3)把list、dict、str等Iterable变成Iterator可以使用iter()函数。</strong></p>
<p><strong>迭代器与生成器的区别：<img src="https://img-blog.csdnimg.cn/20190604135527264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></strong></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>什么是闭包？</strong></p>
<p>1）闭包的概念就是当我们在函数内定义一个函数时，这个内部函数使用了外部函数的临时 变量，且外部函数的返回值是内部函数的引用时，我们称之为闭包。</p>
<p>2）闭包再理解 ：内部函数对外部函数作用域里变量的引用(非全局变量),则称内部函数为闭包。</p>
<p>3）nonlocal关键字：显式的指定变量不是闭包的局部变量<br><strong>闭包的一个常用场景就是装饰器。</strong></p>
<p>闭包的实际例子：<img src="https://img-blog.csdnimg.cn/20190604140158293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>函数line与变量a,b构成闭包。在创建闭包的时候,我们通过line_conf的参数a,b说明了这两个变量的取值,这样,我们就确定了函数的最终形式(y=x+1和y=4x+5)。<br><strong>优点：闭包也具有提高代码可复用性的作用。</strong></p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p><strong>什么是装饰器？</strong><br>答：装饰器本质上是一个函数，该函数用来处理其他函数，它可以让其他函数在不需要修改代码的<br>前提下增加额外的功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，<br>比如：插入日志、性能测试、事务处理、缓存、权限校验等应用场景。<br><strong>为什么需要装饰器？</strong><br>答：写代码要遵循 开放封闭 原则,虽然在这个原则是用的面向对象开发,但是也适用于函数式编程,简单来说,它规定已经实现的功能代码不允许被修改,但可以被扩展,即:<br><strong>1.封闭:已实现的功能代码块<br>2.开放:对扩展开发。</strong><br><strong>装饰器实例：动画片问题</strong><br><img src="https://img-blog.csdnimg.cn/2019060414422555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>运行结果为：‘开始播放动画片《喜羊羊和灰太狼》‘</p>
<p><strong>装饰器的功能：</strong></p>
<ol>
<li>引入日志</li>
<li>函数执行时间统计</li>
<li>执行函数前预备处理</li>
<li>执行函数后清理功能</li>
<li>权限校验等场景</li>
<li>缓存</li>
</ol>
<p><strong>当有多个装饰器时：（以两个为例）</strong><br>运行有两个装饰器的程序时可以分为有两个步骤：<br>1.装饰函数阶段：装饰函数时，先用第二个装饰器，再用第一个。<br>2.调用函数阶段：调用函数阶段，先执行第一个装饰器，再执行第二个装饰器。</p>
<p><strong>多个装饰器应用实例：学生管理系统，需要判断用户是否登陆账号，以及判断账号有无权限执行操作。</strong></p>
<pre><code>    #1.判断用户是否登录
    #2.判断用户是否有权限
    #3.系统中的用户信息
db = {
    &apos;root&apos;: {&apos;name&apos;: &apos;root&apos;,
             &apos;passwd&apos;: &apos;westos&apos;,
             &apos;is_super&apos;: 0},
    &apos;admin&apos;: {&apos;name&apos;: &apos;admin&apos;,
              &apos;passwd&apos;: &apos;westos&apos;,
              &apos;is_super&apos;: 1}
}

login_user_session = {}
#存储当前登录用户信息
def is_login(fun):
    def wrapper1(*args, **kwargs):
        if login_user_session:
            result = fun(*args, **kwargs)
            return result
        else:
            print(&quot;跳转登陆&quot;.center(50, &apos;*&apos;))
            user = input(&apos;user:&apos;)
            passwd = input(&apos;Passwd:&apos;)
            if user in db:
                if db[user][&apos;passwd&apos;] == passwd:
                    login_user_session[&apos;username&apos;] = user
                    print(&quot;登陆成功&quot;)
                    result = fun(*args, **kwargs)
                    return result
                else:
                    print(&quot;密码错误&quot;)
            else:
                print(&quot;该用户不存在&quot;)
    return wrappe1
     #判断是否有权限修改
def is_permisson(fun):
    def wrapper2(*args, **kwargs):
        print(&quot;判断是否有权限......&quot;)
        current_user = login_user_session.get(&apos;username&apos;)
        permission = db[current_user][&apos;is_super&apos;]
        if permission == 1:
            result = fun(*args, **kwargs)
            return result
        else:
            print(&quot;用户%s没有权限&quot; % (current_user))
    return wrapper2
@is_login
@is_permisson
def delete():
    return &apos;正在删除用户信息&apos;
result = delete()
print(result)


**** 被装饰的过程: 
1). delete = is_permission(delete)   # delete = wrapper2
2). delete = is_login(delete)        # delete = is_login(wrapper2)       # delete = wrapper1
*******被调用的过程: 
delete()    ------&gt;  wrapper1()   ---&gt; wrapper2()  ---&gt; delete()
&quot;&quot;&quot;</code></pre><h2 id="练习部分"><a href="#练习部分" class="headerlink" title="练习部分"></a>练习部分</h2><p><strong>1.装饰器加日志并存入日志</strong></p>
<pre><code>import datetime
import os
import json


def rizhi(kan):
      def zhuangshi(*args, **kwargs):
          starttime = datetime.datetime.now()
          hostname = os.getenv(&quot;computername&quot;)
          file = open(&apos;rizhi.txt&apos;, &apos;a+&apos;)
          json.dumps(str(starttime))
          json.dumps(str(hostname))
          file.write(str(starttime))
          file.write(str(hostname))
          file.close()
          kan(*args, **kwargs)

      return zhuangshi


  @rizhi
  def chakan():
      result = &apos;you program is OK&apos;
      print(&quot;运行完成，函数结果为：%s&quot; % result)
      return result</code></pre><p><strong>2.斐波那契数列高速递归</strong></p>
<pre><code>import time


def num_catch(func):
    list = []

def wapper1(*args):
    if func(*args) not in list:
        list.append(func(*args))
        return func(*args)
    else:
        return func(*args)
return wapper1


def timeit(func):
    def wapper2(*args, **kwargs):
        start = time.time()
        time0 = func(*args, **kwargs)
        end = time.time()
        print(&quot;执行时间为：%s&quot; % (end - start))
        return time0

    return wapper2


@num_catch
@timeit
def fibonacci(n):
    if (int(n) &lt;= 2):
        return 1
    result = fibonacci(int(n) - 1) + fibonacci(int(n) - 2)
    return result
print(fibonacci(10))</code></pre><p><strong>3.求微信好友省份前五</strong></p>
<pre><code>import itchat

itchat.auto_login()
friends = itchat.get_friends(update=True)
prov_dict = {}
for fri_info in friends[1:]:
    prov = fri_info[&apos;Province&apos;]
    if prov and prov not in prov_di**加粗样式**ct.keys():
        prov_dict[prov] = 1
    elif prov:
        prov_dict[prov] += 1
prov_dict_top10 = sorted(prov_dict.items(),key=lambda x:x[1],reverse=True)[0:10]
print(prov_dict_top10)</code></pre><h2 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h2><p><strong>工具包的定义：模块就是工具包，想要使用这个工具包的工具就要导入这个模块</strong></p>
<p>模块是非常简单的Python文件，一个python文件是一个python模块，两个python文件就是两个python模块。<br><strong>模块导图：<img src="https://img-blog.csdnimg.cn/20190610175317202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></strong><br><img src="https://img-blog.csdnimg.cn/20190610175559980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>如何导入模块？</strong><br><strong>答：当解释器遇到import语句时，如果模块在当前的搜索路径就会被导入。</strong><br><strong>为什么一定要加上模块名导入呢？</strong><br><strong>答：因为可能存在这样一种情况:在多个模块中含有相同名称的函数,如果只是通过函数名来调用,解释器无法知道到底要调用哪个函数。所以如果像上述这样引入模块的时候,调用函数必须加上模块名。</strong><br><img src="https://img-blog.csdnimg.cn/20190610182807524.png" alt="在这里插入图片描述"><strong>如果只需要用到模块中的某个函数/变量/类，如何导入呢？</strong><br><strong>答：通过这种方式引入的时候,调用函数时只能给出函数名,不能给出模块名,但是当两个模块中含有相同名称函数的时候,后面一次引入会覆盖前一次引入。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/Python高级特性/" data-id="cjyigf8vy0005pb5ekdwn27hw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python异常处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/Python异常处理/" class="article-date">
  <time datetime="2019-07-25T05:38:52.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/Python异常处理/">Python异常处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>什么是异常？</strong><br><strong>答：异常即是一个时间，该事件会在程序执行过程中发生，影响了程序的正常运行。当python脚本发生异常时我们需要捕获处理它，否则程序会终止运行。</strong><br>常见的异常：<br><img src="https://img-blog.csdnimg.cn/20190610184118439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>异常处理举例：</strong><br><img src="https://img-blog.csdnimg.cn/20190610184248461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>try的工作原理：当开始一个try语句后，python就在当前程序的上下文中做标记，这样当一场出现的时候就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常</strong><img src="https://img-blog.csdnimg.cn/20190610184521644.png" alt="在这里插入图片描述"><br>try语句测试实例：<img src="https://img-blog.csdnimg.cn/20190610184603933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>异常处理的一些其他用途：</strong><br>       除了处理实际的错误条件之外，对于异常还有许多其它的用处。在标准 Python 库中<br>一个普通的用法就是试着导入一个模块，然后检查是否它能使用。导入一个并不存在的<br>模块将引发一个 ImportError 异常。<br>      你可以使用这种方法来定义多级别的功能――依靠在运行时哪个模块是有效的，或支持多<br>种平台 (即平台特定代码被分离到不同的模块中)。</p>
<p> <strong>触发异常</strong><br>    使用raise语句自己触发异常，raise语法格式如下：raise[Exception[,args [,traceback]]]<br>   语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，<br>args 是自已提供的异常参数。</p>
<pre><code>用户自定义异常实例
age=input(&quot;please input age:&quot;)
if not 0&lt;age&lt;120:
    raise AgeException(&quot;my excepition is raised &quot;)</code></pre><p><img src="https://img-blog.csdnimg.cn/20190610185541841.png" alt="在这里插入图片描述"><br><strong>触发异常框图</strong><br><img src="https://img-blog.csdnimg.cn/20190610185740412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/Python异常处理/" data-id="cjyigf8vw0004pb5epb2f584k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python垃圾回收机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/Python垃圾回收机制/" class="article-date">
  <time datetime="2019-07-25T05:37:43.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/Python垃圾回收机制/">Python垃圾回收机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p><strong>目录：1.对象池<br>              2.垃圾回收：计数机制<br>              3.垃圾回收：标记-清楚<br>              4.垃圾回收：分代收集<br>              5.gc模块</strong><br>  <strong>小整数对象池：<br>  1）整数在程序中的使用非常广泛，Python为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。</strong><br>  <strong>2)Python对小整数的定义是[-5，257]这些整数对象是提前建立好的，不会被垃圾回收。在一个Python的程序中，所有位于这个范围内的整数使用的都是同一个对象。</strong></p>
<p><strong>大整数对象池：<br>1）每一个大整数，均创建一个新的对象。</strong></p>
<p><strong>itern机制</strong><br>       string interning(字符串驻留)：它通过维护一个字符串常量池（string intern pool），从而试图只保存为字符串对象，达到即高效又节省内存的处理字符串的目的。<br>       在创建一个新的字符串对象后，Python先比较常量池中是否有相同的对象（interned），有的话则将指针已有对象，并减少新对象的指针，新对象由于没有引用计数，就会被垃圾回收机制收掉，释放出内存。<br>       字符串（含有空格）不可修改，没开启inern机制，不共用对象，引用计数为0，销毁。<br>  <strong>垃圾回收机制—-内存溢出与内存泄漏</strong><br>      1.内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比方说，定义了20个字节大小的内存空间，却写入了21个字<br>节的数据。通俗的说，就是内存不够，没办法支持当前程序。当发生内存溢出时，程<br>序将无法进行，强制终止。<br>      2.内存泄漏 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏危害可以忽略，但内存泄漏堆积后果很严重，无论多少内存，迟早会被占光。如果发生内存泄漏，那么可用内存会逐渐减少，从而降低性能。<br>      <strong>memory.leak会最终会导致out of memory！</strong></p>
<p><strong>为什么需要Garbage collection？</strong><br>      为了防止内存泄漏，对编程语言来说，GC就是一个无名英雄，默默地做着贡献。打个比方，天鹅在水面优雅地游动时，实际上脚蹼却在水下拼命的划水。GC也是如此。在由编程语言的美丽的源代码这片水下，GC在拼命地将垃圾回收再利用。</p>
<p><strong>Python采用的时引用计数机制为主，标记-清除和分代收集两种机制为辅的策略</strong><br><strong>引用计数：</strong><br>     GC原本是一种“释放怎么都无法被引用的对象的机制”。那么人们自然而然地就会想到，可以让所有对象事先记录下“有多少程序引用自己”。让各对象知道自己的“人气指数”，从而让没有人气的对象自己消失，这就是引用计数法<br>     python里每一个东西都是对象，它们的核心就是结构体：PyObject</p>
<p><img src="https://img-blog.csdnimg.cn/20190610195447344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当引用计数为0时，该对象生命就该结束了</p>
<p><strong>导致引用计数+1的情况</strong><br>1)对象被创建，例如a=23<br>2)对象被引用，例如b=a<br>3)对象被作为参数，传入到一个函数中，例如func(a)<br>4)对象作为一个元素，存储在容器中，例如list1=[a,a]</p>
<p><strong>导致引用计数-1的情况</strong><br>1)对象的别名被显式销毁，例如def a<br>2)对象的别名被赋予新的对象，例如a=24<br>3)一个对象离开它的作用域，例如f函数执行完毕时func函数中的局部变量（全局变量不会）<br>4）对象所在的日哦能勾起被销毁，或从容器中删除对象。</p>
<p><strong>优点：1）简单 2）实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定世纪。实时性还带来一个好处：处理回收内存的时间分摊到了平时 。</strong></p>
<p><strong>缺点：1）维护引用计数消耗资源 2）循环引用</strong></p>
<p><strong>循环引用：<img src="https://img-blog.csdnimg.cn/20190610201034626.png" alt="在这里插入图片描述"></strong><br>list1与list2相互引用,如果不存在其他对象对它们的引用,list1与list2的引用<br>计数也仍然为1,所占用的内存永远无法被回收,这将是致命的。 对于如今<br>的强大硬件,缺点1尚可接受,但是循环引用导致内存泄露,注定python还将<br>引入新的回收机制。(标记清除和分代收集)</p>
<p><strong>标记清除：如它的字面意思一样,GC 标记 - 清除算法由标记阶段和清除阶段构成。标记阶段是把所有活动对象都做上标记的阶段。清除阶段是把那些没有标记的对象,也就是非活动对象回收的阶段。通过这两个阶段,就可以令不能利用的内存空间重新得到利用。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2019061020142953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果说被标记的对象是存活的,剩下的未被标记的对象只能是垃圾,这意味着我们的代码不再会使用它了。<br><img src="https://img-blog.csdnimg.cn/20190610201603486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>清除这些无用的垃圾对象，把它们送回到可用列表</p>
<p><strong>分代收集：分代垃圾回收在对象中导入了“年龄”的概念，通过优先回收容易成为垃圾的对象，提高垃圾回收的效率。</strong><br><img src="https://img-blog.csdnimg.cn/20190610201845251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>什么是分代垃圾回收？</strong><br>新生代对象和老年代对象：<br>1）分代垃圾回收中把对象分类成几代，针对不同的代使用不同的GC算法，我们把刚生成的对象称为新生代对象，到达一定年龄的对象称为老年代对象。<br>2）新生代GC将存活了一定次数的新生代对象当作老年代对象来处理。我们把类似于这样的新生代对象上升为老年代对象的情况称为晋升。<br>3）老年代对象很难成为垃圾，所以我们对老年代对象减少执行GC的频率，从而提高效率。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/Python垃圾回收机制/" data-id="cjyigf8vr0001pb5egh8oupx3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python基础——面向对象高级特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/Python基础——面向对象高级特性/" class="article-date">
  <time datetime="2019-07-25T02:28:08.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/Python基础——面向对象高级特性/">Python基础——面向对象高级特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h1 id="类属性与实例属性"><a href="#类属性与实例属性" class="headerlink" title="类属性与实例属性"></a>类属性与实例属性</h1><p><strong>基础概念</strong>：类属性就是对类对象所拥有的属性，它被所有类对象的实例对象所共有，在内存中只存在一个副本。</p>
<p>在之前的学习中，面向对象的基本特性中接触的就是<strong>实例属性</strong>，也被称为对象属性，它不被所有类对象的实例化对象所共有，在内存中的副本个数取决于对象个数。</p>
<p><strong>类属性与实例属性的区别</strong>：<br>1.定义不同。<br>2.所占用的内存不同。<br>3.调用的时候不同。<br>类属性：直接定义在类里边，只存一份，与对象的个数无关（类名.属性名，对象名，属性名）<br>对象属性：属性和对象绑定在一起：self.name=‘xxxx’，有多少个对象，就需要存储多少份；对象名.属性名。</p>
<p><strong>实例：日期显示以及字符串处理</strong></p>
<pre><code>import string
from collections import Counter


class People(object):
    # 类属性， 在内存中只存一份；
    country = &apos;china&apos;
    __gender = &apos;male&apos;
    def __init__(self, name, age, money):
        # self.name, self.age, self.money: 实例属性（有多少个对象， 就有多少份属性;）
        self.name = name
        self.age = age
        self.money = money


# 实例化三个对象， 有三份实例属性；
p1 = People(&quot;westos1&quot;, 10, 1000000000)
print(p1.name)
print(p1.age, id(p1.age))
print(p1.money, id(p1.money))
p2 = People(&quot;westos2&quot;, 10, 1000000000)
print(p2.money, id(p2.money))
p3 = People(&quot;westos3&quot;, 10, 1000000000)
print(p3.money, id(p3.money))



# 调用p1, p2, p3的属性country： 当对象没有country属性时， 调用类的属性country;
print(p1.country, p2.country, p3.country)
# 设置p2对象的属性country为‘us’, 并不会修改类的属性；
p2.country = &apos;us&apos;
# 调用p1, p2, p3的属性country： 当对象没有country属性时， 调用类的属性country; 当对象有country‘属性时， 调用拥有的country&apos;属性；
print(p1.country, p2.country, p3.country)

# 类属性名如果前面添加双下划线， 那么他是私有属性， 类的外部时不能访问的；
print(p1._People__gender)
print(People.country)</code></pre><h1 id="静态方法与类方法"><a href="#静态方法与类方法" class="headerlink" title="静态方法与类方法"></a>静态方法与类方法</h1><p><strong>基础概念</strong>：<br><strong>1.类方法</strong>：类方法是类对象所拥有的方法，需要用<strong>装饰器</strong>一般以@classmethod来标识其为类方法。<br>1).对于类方法，第一个参数必须是类对象，让类对象作为第一个参数。（cls是形参，可以修改为其他变量名，但是最好用‘cls’）<br>2).能够通过实例对象和类对象去访问。</p>
<p><strong>2.静态方法</strong>：静态方法需要用装饰器一般以@staticmethod来标识其为静态方法。<br>1).静态方法不需要定义参数<br>    2).能够通过实例对象和类对象去访问。</p>
<pre><code>实例：日期显示


class Date(object):

    def __init__(self, year=2008, month=8, day=8):
    #魔术方法（构造方法）
        self.year = year
        self.month = month
        self.day = day

    def echo(self):
    #实例方法
        print(&apos;%s-%s-%s&apos; % (self.year, self.month, self.day))

    @classmethod
    #类方法，默认传递的第一个参数为类名
    def as_string(cls, str):
        month, day, year = str.split(&apos;/&apos;)
        #将字符串进行处理分割，并且将其传给echo函数
        d1 = cls(year, month, day)
        return d1
        #返回处理好的字符串

    @staticmethod
    #静态方法，不需要引入参数
    def is_right(str):
        month,day,year = map(int,str.split(&apos;/&apos;）
        #对字符串进行修改
    return 0&lt;month&lt;12 and 0&lt;day&lt;31 and day &gt;0
    #返回值为布尔值，判断输入的年日月份是否合法

    d=Date()
    d.echo()
    #实例方法的结果导出，输入出来，结果为对象的属性：2008-8-8

    str = ‘12/23/2008’
    #导入一个新的字符串
    d = Date.as_string(str)
    #将字符串分段处理，将值返回给类方法
    d.echo()
    #输出类方法处理完的结果，结果为2018-12-3



    str = &apos;13/32/-1&apos;
    #输入不合法字符串，返回值为False
    print(Date.is_right(str))
    #将不合法的输出打印出来，结果为False</code></pre><h1 id="Property属性"><a href="#Property属性" class="headerlink" title="Property属性"></a>Property属性</h1><p><strong>什么是Property属性？</strong><br>1).Python内置的@property装饰器就是负责把一个方法变成属性调用的。<br>2).@property本身又创建了另一个装饰器@state.settrt，负责把一个setter方法变成属性赋值，于是我们就拥有了一个可以控制的属性操作。<br>3).@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序就减少了出错的可能性。</p>
<p><strong>代码实例</strong>：修改删除日期月份</p>
<pre><code>import time


class Date(object):
    def __init__(self, year=None, month=None, day=None):
        self.__year = year
        self.__month = month
        self.__day = day

    @property # 类属性, 获取属性名时简洁: 对象名.属性名
    def month(self):
        if 0 &lt; self.__month &lt;= 12:
            return self.__month

    @month.setter # 设置属性装饰器， 当设置属性时简洁： 对象名.属性名=新的值
    def month(self, month):
        if 0 &lt; self.__month &lt;= 12:
            self.__month = month
            return  True

    @month.deleter # 删除属性装饰器， 当删除属性时简洁： del 对象名.属性名
    def month(self):
        del self.__month


d = Date(2019, 10, 10)


print(d.month)
d.month = 12
print(&quot;正在修改月份....&quot;)
print(d.month)

del d.month
print(&quot;正在删除月份....&quot;)
print(d.month)




# 不简洁的方式： 不太建议
# # 获取月份====print(d.month)
# print(d.month())
#
# # 设置月份======d.month = 12
# d.set_month(12)
# print(d.month())
#
# # 删除月份信息 ===== del d
# d.del_year()
# print(&quot;正在删除月份信息.....&quot;)
# print(d.month())</code></pre><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p><strong>什么是单例模式？</strong><br>    <img src="https://img-blog.csdnimg.cn/20190617104739994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>基本概念</strong>：对于系统的某些类来说，只有一个实例是十分重要的，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个<strong>窗口管理器</strong>或者<strong>文件系统</strong>；一个系统只能有一个<strong>计时工具或者ID生成器</strong>。如在Windows中就只能打开一个任务管理器。将窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中的某个对象唯一性即一个类只能有一个实例非常重要。</p>
<p><strong>单例模式代码实现</strong>：</p>
<pre><code>def singleton(cls):
    &quot;&quot;&quot;
    用来装饰类的装饰器: 实例化类时， 只实例化一个对象；
    &quot;&quot;&quot;
    # 初始化一个字典instances, key: 类名 ， value: 类实例化的对象
    instances = {}
    def wrapper(*args, **kwargs):
        &quot;&quot;&quot;
        如果类在缓存instances存在时， 直接返回类对应的对象;
        如果类不在缓存instances存在时， 先实例化对象, 将类名和对象名存储到缓存中instances;
        &quot;&quot;&quot;
        if cls in instances:
            return  instances[cls]
        else:
            # instances[cls] = cls(*args, **kwargs)
            obj = cls(*args, **kwargs)
            instances[cls] = obj
            return obj
    return  wrapper

@singleton   # @single  =====&gt; Student = singleton(Student)
class Student(object):
    pass

# # 如果类没有被装饰器sigleton装饰的化， 返回的s1和s2时两个不同的对象（内存地址不同）;
# s1 = Student()
# s2 = Student()
# print(s1, s2)

# 如果类有被装饰器sigleton装饰， 返回的s1和s2时两个相同的对象（内存地址相同）;
s1 = Student()
s2 = Student()
print(s1, s2</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/Python基础——面向对象高级特性/" data-id="cjyigf8vt0002pb5ekncxbdnp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python面向对象——魔术方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/Python面向对象——魔术方法/" class="article-date">
  <time datetime="2019-07-25T01:41:31.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/Python面向对象——魔术方法/">Python面向对象——魔术方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h2><p><strong>魔术方法名称</strong>：<strong>name</strong>                          查看类、函数、方法等的名字<br>                            <strong>module</strong>                      类定义所在的模块<br>                            <strong>class</strong>                对象或类所属的类<br>                            <strong>bases</strong>                当前类的基类（父类）<br>                            <strong>doc</strong>                类、函数的文档帮助、没有定义为None<br>                            <strong>mro</strong>                Method Resolution Order方法解析顺序<br>                            <strong>dict</strong>                 类或实例的属性，可写的字典</p>
<p><strong>查看属性：</strong><br><strong>dir</strong> 返回类或者对象的左右成员名称列表，dir()函数就是调用<strong>dir</strong>(）。</p>
<p>1)如果dir([obj])参数包含方法<strong>dir</strong>()，该方法将被调用<br>2)如果Obj不包含<strong>dir</strong>(),该方法将最大限度收集属性信息。</p>
<p><strong>dir</strong>(obj)对于不同类型的对象obj具有不同的行为：<br>1.如果对象是模块对象，返回的列表包含模块的属性名和变量名<br>2.如果对象是类型或者类对象，返回的列表包含类的属性名，及它的基类的属性名<br>3.如果obj不写 即dir()，返回列表包含内容不同</p>
<p>_在模块中，返回模块的属性和变量名。<br>_在函数中，返回本地作用域的变量名。<br>_在方法中，返回本地作用域的变量名。</p>
<h2 id="创建，初始化与销毁"><a href="#创建，初始化与销毁" class="headerlink" title="创建，初始化与销毁"></a>创建，初始化与销毁</h2><p><strong>面试常问</strong>：python中<strong>new</strong>，<strong>init</strong>,<strong>del</strong>的区别？<br>1).new的功能是在生成对象之前所作的操作，接受的参数是cls类，负责对象的创建工作。<br>2).init是在对象生成之后，对他的属性进行丰富，完善，他所接受的是self对象，负责对象的初始化操作。<br>3).对象生成是在new里面return（返回一个对象）</p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>类型判断要使用type或者isinstance,不能通过判断print输出是否带引号来判断输出值的类型。<br>1).str()与repr()都是python中的内置函数，是直接用来格式化字符串的函数。<br>2).而<strong>str</strong>与<strong>repr</strong>是在类(对象)中对类(对象)本身进行字符串处理。</p>
<p>str：返回一个可以用来表示对象的可打印的友好字符串。<br>    -对字符串，返回本身<br>    -没有参数，则返回空字符串<br>    -对类<strong>str()</strong>成员控制其行为。该成员不存在，则使用其<strong>repr</strong>()成员。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>init</strong>(self)                                                        转换成整形<br><strong>long</strong>(self)                                                      转换成长整型<br><strong>float</strong>(self)                                                      转换成浮点型<br><strong>complex</strong>(self)                            转换成复数型<br><strong>oct</strong>(self)                                  转换成八进制<br><strong>hex</strong>(self)                                  转换成十六进制<br><strong>index</strong>(self)    如果你定义了一个可能被用来做切片的数值类型，就用index定义</p>
<h2 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h2><p><img src="https://img-blog.csdnimg.cn/20190625173017202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190625173048495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190625173114407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="重复，连接与成员操作符"><a href="#重复，连接与成员操作符" class="headerlink" title="重复，连接与成员操作符"></a>重复，连接与成员操作符</h2><p><img src="https://img-blog.csdnimg.cn/20190625173209719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190625173351786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><img src="https://img-blog.csdnimg.cn/20190625173418875.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190625173429624.png" alt="在这里插入图片描述"></p>
<h2 id="with语句安全上下文"><a href="#with语句安全上下文" class="headerlink" title="with语句安全上下文"></a>with语句安全上下文<img src="https://img-blog.csdnimg.cn/20190625173458959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/Python面向对象——魔术方法/" data-id="cjyigf8vv0003pb5exlpte59g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学生管理系统-Python面向对象版本" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/学生管理系统-Python面向对象版本/" class="article-date">
  <time datetime="2019-07-25T01:37:12.359Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="osk-foundation49-blog-vim"><a href="#osk-foundation49-blog-vim" class="headerlink" title="osk@foundation49 blog]$ vim "></a>osk@foundation49 blog]$ vim </h2><p>title: 学生管理系统(Python面向对象版本)<br>date: 2019-07-25 09:36:40</p>
<h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2>
        
          <p class="article-more-link">
            <a href="/2019/07/25/学生管理系统-Python面向对象版本/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/学生管理系统-Python面向对象版本/" data-id="cjyigf8w30008pb5ewr036eyc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构导论" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/数据结构导论/" class="article-date">
  <time datetime="2019-07-25T01:33:57.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/数据结构导论/">数据结构导论</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="算法引入"><a href="#算法引入" class="headerlink" title="算法引入"></a>算法引入</h2><p><strong>什么是算法？</strong><br>算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略机制。对于算法而言，实现的语言并不重要，重要的是思想。算法可以有不同的语言描述实现版本，我们下面的知识都会用Python语言进行描述实现。</p>
<p><strong>算法的五大特性</strong><br>(1)输入，有0个或多个输入。<br>(2)输出，至少有一个或多个输出<br>(3)有穷性，有限的步骤之后会自动结束<br>(4)确定性，每一步都有确定的含义<br>(5)可行性，每一步都是可行的</p>
<h2 id="算法效率衡量"><a href="#算法效率衡量" class="headerlink" title="算法效率衡量"></a>算法效率衡量</h2><p><strong>1.执行时间反映算法效率内容</strong><br>实现算法程序的执行时间可以反映出算法的效率，即算法的优劣。</p>
<p><strong>2.单靠时间值绝对可信吗</strong><br>程序的运行离不开计算机环境（包括硬件和操作系统），单独依靠运行时间来比较算法的优劣并不一定是客观准确的。<br>因此在这里，我们引入了一个概念——时间复杂度<br>(1)时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T（n）=O（g（n））,则称O(g(n))为算法A的渐进时间复杂度，简称时间复杂度。<br>(2)大O记法：计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。</p>
<p><strong>3.时间复杂度的几条计算规则</strong><br>1.基本操作：只有常数项，认为时间复杂度为O(1)<br>2.顺序结构：时间复杂度按加法进行计算。<br>3.循环结构：时间复杂度按乘法进行计算。<br>4.分支结构：时间复杂度取最大值。</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>先来看一道题:<br>    如果 a+b+c=1000，且 a2+b2=c^2（a,b,c 为自然数），如何求出所有a、b、c可能的组合?</p>
<p>下面给出这一道题的两种解题代码：<br>第一种：时间复杂度T(n) = O(n<em>n</em>n) = O(n**3)</p>
<pre><code>for a in range(0,1001):
    for b in range(0,1001):
        for c in range(0,1001):
            if a**2 + b**2  == c**2 and a+b+c ==100:
                print(&apos;a,b,c:%d,%d,%d&apos; % (a,b,c))</code></pre><p>第二种：T(n) = O(n<em>n</em>(1+1)) = O(n<em>n)=O(n*</em>2)</p>
<pre><code>for a in range(0,1001):
    for b in range(0,1001-1):
        c = 1000-a-b
        if a**2 + b**2 == c**2:
            print(&apos;a,b,c:%d,%d,%d&apos; % (a,b,c))</code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><img src="https://img-blog.csdnimg.cn/20190718102625896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Python中的timeit模块可以用来测试一小段Python代码的执行速度。<br><img src="https://img-blog.csdnimg.cn/20190718104000727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>Python中的timeit模块可以用来测试一小段Python代码的执行速度。<br>class timeit.Timer(stmt=’pass’,setup=’pass’,timer=&lt;timer)<br>Timer是测量小段代码执行速度的类。<br>stmt参数是要测试的代码语句（statment）<br>setup参数试运行代码时需要的设置<br>timer 参数是一个定时器函数，与平台有关。<br>timeit.Timer.timeit(number=1000000)<br>测试语句执行速度的对象方法<br>number参数是测试代码时的测试次数，默认为1000000次。</p>
<p><img src="https://img-blog.csdnimg.cn/20190718104719445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>列表添加测试</p>
<p><img src="https://img-blog.csdnimg.cn/20190718104810207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>列表添加元素设置<br><img src="https://img-blog.csdnimg.cn/20190718104840706.png" alt="在这里插入图片描述"><br>列表删除测试</p>
<p>下面，我们列出列表，以及字典操作中常见的时间复杂度<br><img src="https://img-blog.csdnimg.cn/20190718105245770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/数据结构导论/" data-id="cjyigf8wf000epb5eo7qozow4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构中的顺序表和链表-Python语言实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/数据结构中的顺序表和链表-Python语言实现/" class="article-date">
  <time datetime="2019-07-25T01:29:48.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/数据结构中的顺序表和链表-Python语言实现/">数据结构中的顺序表和链表(Python语言实现)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>问题提出：我们如何用Python中的类型来保存一个班的学生信息？如果想要快速的通过学生姓名获取其信息呢？</strong><br><img src="https://img-blog.csdnimg.cn/20190718110158792.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019071811071063.png" alt="在这里插入图片描述"></p>
<p>算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体。<br><img src="https://img-blog.csdnimg.cn/20190718110346640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Python提供现成的数据结构类型叫做Python的内置数据结构，比如列表、元组、集合、字典。<br>Python系统里面没有直接定义需要自定义的成为Python的扩展数据结构，比如栈、队列等。</p>
<h2 id="顺序表的基本形式"><a href="#顺序表的基本形式" class="headerlink" title="顺序表的基本形式"></a>顺序表的基本形式</h2><p><strong>1.定义：所谓顺序表，就是将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由他们的存储顺序自然表示。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2019071811094910.png" alt="在这里插入图片描述"><br>图a，每个元素所占存储单元大小固定相同。<br>图b，每个元素所占的存储单元大小不相同。存储一个链接地址。<br><img src="https://img-blog.csdnimg.cn/201907181122123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="顺序表的结构与实现"><a href="#顺序表的结构与实现" class="headerlink" title="顺序表的结构与实现"></a>顺序表的结构与实现</h2><p><strong>顺序表的两种基本实现方式</strong><br>图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一快存储区里。<br>图b为分离式结构，存储表信息的单元与元素存储区以连续的方式安排在两块存储区里。<br><img src="https://img-blog.csdnimg.cn/20190718112903200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>元素存储区替换</strong><br>一体式结构：若想更换数据区，则只能整体搬迁，即整个顺序表对象改变了。<br>分离式结构：若想更换数据区，只需要将信息区中的数据区链接地址更新即可，而该顺序表对象不变。</p>
<p><strong>元素存储区扩充</strong><br>1.只有分离式结构的元素存储区可以扩充。<br>2.扩充的两种策略：<br>1）每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置。<br>特点：节省空间，但是扩充操作频繁，操作次数多。<br>2）每次扩充容量加倍，如每次扩充增加一倍存储空间。<br>特点：减少了扩充操作的执行此书，但可能会浪费空间资源。以空间换时间，推荐此方式。</p>
<h2 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h2><p><strong>1.增加元素的三种方式。</strong><br><img src="https://img-blog.csdnimg.cn/20190718115133306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190718115234880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Python中的顺序表"><a href="#Python中的顺序表" class="headerlink" title="Python中的顺序表"></a>Python中的顺序表</h2><p><strong>Python中的list和turple两种类型采用了顺序表的实现技术。<br>  list是可变类型，即采用分离式技术实现的动态顺序表。<br>  turple是不可变型，即不变的顺序表。</strong></p>
<p><strong>list的基本丝线技术</strong><br>1.Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，具有以下特征：(1)顺序表：基于下标的高效元素访问和更新，时间复杂度是O(1);<br>        (2)分离式技术：允许任意加入元素，而且在不断加入元素的过程中，表对象的id不变。</p>
<p><strong>list元素存储区扩充规则</strong><br>1.在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；</p>
<ol start="2">
<li>在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。</li>
<li>如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。<br> 原因: 为了避免出现过多空闲的存储位置。</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>顺序表的构建需要预先知道数据大小来申请连续的存储空间，而在进行空充时又需要进行数据的搬迁，所以使用起来并不是很灵活，但是链表结构可以充分利用计算机的内存空间，实现灵活的内存动态管理。</strong><br><img src="https://img-blog.csdnimg.cn/20190718135115822.png" alt="在这里插入图片描述"><br><strong>1.链表的定义：链表是一种常见的基础书籍结构，是一只种类线性表，但是不想顺序表一样连续存储数据，而是在每一个节点（数据存储单元）里存放下一个节点的位置信息。（即地址）</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190718140426689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p><strong>1.单链表的定义：单向链表也叫单链表，每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190718140636677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2.节点实现：</strong></p>
<pre><code>class SingleNode(object):
    &quot;&quot;&quot;单链表的节点“”“
    def ——init——（self，item）：
        #item存放数据元素
        self。item = item
        #next是下一个结点的标示
        self.next = None</code></pre><p><strong>3.单链表的操作</strong><br>length()     链表长度<br>travel()     遍历整个链表<br>add(item)     链表头部添加元素<br>append(item)     链表尾部添加元素<br>insert(pos, item)     指定位置添加元素<br>remove(item)     删除节点<br>search(item)    查找节点是否存在<br>is_empty()     链表是否为空</p>
<p><strong>4.单链表的头部添加元素与尾部添加元素</strong><br><img src="https://img-blog.csdnimg.cn/20190718141204607.png" alt="在这里插入图片描述"><br><strong>5.单链表在指定位置添加元素</strong><br><img src="https://img-blog.csdnimg.cn/20190718141251741.png" alt="在这里插入图片描述"><br><strong>6.删除节点</strong><br><img src="https://img-blog.csdnimg.cn/20190718141853853.png" alt="在这里插入图片描述"><br><strong>链表与顺序表的对比：</strong><br><img src="https://img-blog.csdnimg.cn/20190718141907473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h2><p>1.单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点。<br><img src="https://img-blog.csdnimg.cn/20190718141959594.png" alt="在这里插入图片描述"><br>2.单向链表的操作及其实现：<br>函数名          功能<br>length()     链表长度<br>travel()     遍历整个链表<br>add(item)     链表头部添加元素<br>append(item)     链表尾部添加元素<br>insert(pos, item)     指定位置添加元素<br>remove(item)     删除节点<br>search(item)    查找节点是否存在<br>is_empty()     链表是否为空</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><strong>特点：每个节点有两个链接：一个指向前一个节点，当此节点为第一个节点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，指向空值。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2019071814233983.png" alt="在这里插入图片描述"><br>操作代码及其实现：</p>
<pre><code>class Node(object):
def __init__(self, element):
    self.element = element
    # 数据域
    self.next = None
    self.prev = None

def __str__(self):
    return self.elelemnt


class DuLinkList(object):
def __init__(self):
    self.head = None

def is_empty(self):
    return self.head == None
#判空
def __len__(self):
    if self.is_empty():
        return 0
    cur = self.head
    linkLen = 0
    while cur:
        cur = cur.next
        linkLen += 1
    return linkLen
#计算长度
def travel(self):
    if not self.is_empty():
        cur = self.head
        while cur.next != None:
            print(cur.element, end=&apos;,&apos;)
            cur = cur.next
        print(cur.element)
    else:
        print(&apos;空链表&apos;)
#遍历每个元素
def add(self, item):
    node = Node(item)
    if self.is_empty():
        self.head = node
    else:
        node.next = self.head
        self.head.prev = node
        self.head = node
#在链表头部添加节点
def append(self, item):
    node = Node(item)
    if self.is_empty():
        self.head = node
    else:
        cur = self.head
        while cur.next != None:
            cur = cur.next
        cur.next = node
        node.prev = cur
#在链表尾部添加节点
def insert(self, index, item):
    if index &lt;= 0:
        self.add(item)
    elif index &gt;= len(self):
        self.append(item)
    else:
        node = Node(item)
        count = 0
        cur = self.head
        while count &lt;= index - 1:
            count += 1
            cur = cur.next
        node.next = cur.next
        cur.next = node
        node.prev = cur
#插入节点
def remove(self,item):
    pre = None
    cur = self.head
    if cur.element == item:
        self.head = self.head.next
    else:
        while cur:
            if cur.element != item:
                pre = cur
                cur = cur.next
            else:
                pre.next = cur.next
                cur.prev = pre.next
                break
#删除节点

if __name__ == &apos;__main__&apos;:
link = DuLinkList()
print(&quot;链表长度：&quot;, len(link))
link.travel()
print(&apos;链表是否为空？&apos;, link.is_empty())
print(&apos;添加头结点：&apos;)
for item in range(5):
    link.append(item)
print(&apos;链表长度：&apos;, len(link))
link.insert(1, &apos;python&apos;)</code></pre><p>指定位置添加节点算法示意图：<br><img src="https://img-blog.csdnimg.cn/20190718150408691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.删除元素算法示意图：<br><img src="https://img-blog.csdnimg.cn/20190718150503623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/数据结构中的顺序表和链表-Python语言实现/" data-id="cjyigf8wb000cpb5enyws2b45" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/25/Python函数/">Python函数</a>
          </li>
        
          <li>
            <a href="/2019/07/25/Python文件处理/">Python文件处理</a>
          </li>
        
          <li>
            <a href="/2019/07/25/Python高级特性/">Python高级特性</a>
          </li>
        
          <li>
            <a href="/2019/07/25/Python异常处理/">Python异常处理</a>
          </li>
        
          <li>
            <a href="/2019/07/25/Python垃圾回收机制/">Python垃圾回收机制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 赵子乔<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>