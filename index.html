<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>钢棍乔师傅的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学无止境...">
<meta property="og:type" content="website">
<meta property="og:title" content="钢棍乔师傅的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="钢棍乔师傅的个人博客">
<meta property="og:description" content="学无止境...">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="钢棍乔师傅的个人博客">
<meta name="twitter:description" content="学无止境...">
  
    <link rel="alternate" href="/atom.xml" title="钢棍乔师傅的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">钢棍乔师傅的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Python开发与人工智能</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-网络编程-Python实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/网络编程-Python实现/" class="article-date">
  <time datetime="2019-07-24T09:40:57.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/网络编程-Python实现/">网络编程(Python实现)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="网络通信概述"><a href="#网络通信概述" class="headerlink" title="网络通信概述"></a>网络通信概述</h2><p><strong>什么是网络？</strong><br>网络就是一种辅助双法或者多方能连接在一起的工具。<br>如果没有网络，可想单机的世界是多么孤单。</p>
<p><strong>使用网络的目的：</strong><br>联通多方然后进行通信用的，即把数据从一方传递给另外一方。<strong>网络编程</strong>就是，让在不同的电脑上的软件能够数据传递，即<strong>进程之间的通信</strong>。</p>
<h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p><strong>如何实现网络通信？——协议</strong><br>有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同语言的人就不行了，为了解决不同种族人之间的语言沟通障碍，现规定国际通用语言是英语，这就是一个规定，这是协议。</p>
<p><strong>网络通信协议是什么？</strong><br>问题：不同种类之间的计算机到底是怎么进行数据传递的呢？<br>答：就像说不同语言的人沟通一样，只要有一种大家都认可都遵守的协议即可，那么这个计算机都遵守的网络通信协议叫做TCP/IP协议。</p>
<p><strong>TCP/IP协议(族)</strong><br>互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP/IP协议，所以大家把互联网的协议简称为TCP/IP协议。<br><img src="https://img-blog.csdnimg.cn/20190724094616852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>什么是IP地址</strong><br>ip地址：用来在网络中标记一台电脑的一串数字，比如192.168.1.1；在本地局域网上是唯一的。<br><img src="https://img-blog.csdnimg.cn/20190724094955452.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>私有IP</strong><br>网络IP中，国际规定有一部分IP地址是用于局域网使用，也就是属于私网IP，不再公网中使用的，他们的范围是：<br> 10.0.0.0～10.255.255.255<br>    172.16.0.0～172.31.255.255<br>    192.168.0.0～192.168.255.255</p>
<p><strong>回环地址IP</strong><br>IP地址127.0.0.1代表本地IP地址，等价于localhost，用<a href="http://127.0.0.1就可以测试本集中配置的WEB服务器。" target="_blank" rel="noopener">http://127.0.0.1就可以测试本集中配置的WEB服务器。</a></p>
<p><strong>子网掩码</strong><br>子网掩码不能呢个单独存在，它必须结合<strong>IP地址</strong>一起使用。</p>
<p><strong>子网掩码的作用：</strong> 将某个IP地址分成网络地址和主机地址两部分，子网掩码的设定必须遵循一定的规则，用来判断两个IP是否在同一个网络。<br>A: 172.25.254.18/24<br>B: 172.25.0.10/24</p>
<p><strong>端口</strong><br>1.端口就好像一个房子的门，是出入这间房子的必经之路。<br>2.端口号只有整数，范围是从0到65535<br>熟悉的服务及其对应的端口号：<br>http ： 80<br>mysql ； 3306<br>https ：443<br>ssh ：22<br>ldqp ： 289</p>
<h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><p><strong>本地进程间通信（IPC）</strong><br>1.队列<br>2.同步<br>3.管道</p>
<p><strong>网络进程间通信</strong><br>问题： 本地通过进程PID来唯一标示一个进程，在网络中如何唯一标示一个进程？<br>答：网络层“IP地址”可以唯一标示网络中的主机，而传输层的”协议+端口“可以唯一标示主机中的应用程序（进程）。因此利用<strong>IP地址，协议，端口</strong>就可以标示网络的进程。</p>
<p><strong>什么是socket？</strong><br>答：socket（简称套接字）是进程间的一种通信方式，能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于Socket来完成通信的。</p>
<p><strong>创建socket</strong><br>在 Python 中 使⽤socket 模块的函数 socket 就可以完成：     socket.socket(AddressFamily, Type)<br>    1). Address Family:<br>        AF_INET: IPV4⽤于 Internet 进程间通信<br>        AF_INET6: IPV6⽤于 Internet 进程间通信<br>    2). Type：套接字类型<br>        SOCK_STREAM: 流式套接字，主要⽤于 TCP 协议<br>        SOCK_DGRAM: 数据报套接字，主要⽤于 UDP 协 议</p>
<h3 id="socket编程-UDP"><a href="#socket编程-UDP" class="headerlink" title="socket编程(UDP)"></a>socket编程(UDP)</h3><p><strong>UDP介绍</strong><br>1.UDP用户数据报协议，是一个无连接的简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证他们能到达目的地，由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重法等机制，故而传输速度很快。<br>2.UDP是一种面向无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p>
<p><strong>UDP特点</strong><br>UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP传输数据时有大小限制，每个传输的数据报必须限定在64KB以内。UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。<br><img src="https://img-blog.csdnimg.cn/20190724105514934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    <strong>服务端代码框架：</strong></p>
<pre><code>import socket
#1.实例化socket对象
udpServer = socket.socket(family=socket.AF_INET,type=socket.SOCK_DGRAM)
#2.绑定IP和端口
#172.25.254.250
#0.0.0.0代表开放所有的IP地址
udpServer.bind((&apos;0.0.0.0&apos;,9001))
print(&apos;等待客户端UDP的连接......&apos;)

#3.接收客户端的连接
recvdata,address = udpServer.recvfrom(1024)
print(&apos;接收到客户端的数据：&apos;,recvdata.decode(&apos;utf-8&apos;))

#4.给客户端回复信息
udpServer.sendto(b&quot;hello client&quot;,address)
#5.关闭socket对象
udpServer.close()</code></pre><p><strong>客户端代码框架：</strong></p>
<pre><code>import socket

udpClient = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
udpClient.sendto(b&apos;hello server&apos;, (&apos;172.25.254.49&apos;, 9001))
recvData, address = udpClient.recvfrom(1024)
print(&apos;接收服务端的数据：&apos;, recvData.decode(&apos;utf-8&apos;))
udpClient.close()</code></pre><p><strong>UDP网络程序框图</strong><br><img src="https://img-blog.csdnimg.cn/20190724111108568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="socket编程-TCP"><a href="#socket编程-TCP" class="headerlink" title="socket编程(TCP)"></a>socket编程(TCP)</h3><p><strong>TCP详解：<br>TCP传输控制协议（英语：Transmission Control Protocol，缩写为TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</strong></p>
<p>三次握手与四次挥手：<br><img src="https://img-blog.csdnimg.cn/20190724111418140.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图：存在两个包，同步序列号SYN 确认包ACK<br><strong>四种状态：</strong> SYN_SENT, LISTEN, SYN_RECV, ESTABLISHED<br>在三次握手中，客户端和服务器端都发送两个包SYN和ACK，只不过服务器端的两个包是一次性发过来的，客户端的两个包是分两次发送的。</p>
<p><strong>TCP数据传输：</strong><br><img src="https://img-blog.csdnimg.cn/20190724112015525.jpg" alt="在这里插入图片描述"><br><strong>TCP四次挥手：</strong><br><img src="https://img-blog.csdnimg.cn/2019072411213786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>四次挥手</strong><br>当A端和B端要断开连接时，需要四次握手，这里称为四次挥手。</p>
<p>断开连接请求可以由客户端发出，也可以由服务器端发出，在这里我们称A端向B端请求断开连接。</p>
<p>第一次挥手</p>
<p>A端向B端请求断开连接时会向B端发送一个带有FIN标记的报文段，这里的FIN是Finish的意思。</p>
<p>第二次挥手</p>
<p>B端收到A发送的FIN后，B段现在可能现在还有数据没有传完，所以B端并不会马上向A端发送FIN，而是先发送一个确认序号ACK，意思是说“你发的断开连接请求我收到了，但是我现在还有数据没有发完，请稍等一下呗”。</p>
<p>第三次挥手</p>
<p>当B端的事情忙完了，那么此时B端就可以断开连接了，此时B端向A端发送FIN序号，意思是这次可以断开连接了。</p>
<p>第四次挥手</p>
<p>A端收到B端发送的FIN后，会向B端发送确认ACK，然后经过两个MSL时长后断开连接。</p>
<p>MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间</p>
<p><img src="https://img-blog.csdnimg.cn/20190724112544330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码实现服务端框架：</p>
<pre><code>import socket

# 1.创建一个socket对象；
# family指定使用IP协议的版本：IPV4：AF_INET; ipv6:AF_INET6
# type指定传输层使用的协议类型：TCP（SOCKET.SOCK_STREAM）,UDP(SOCK_DGRAM)
server = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
# 2.绑定一个IP和端口，供客户端来连接；
server.bind((&apos;172.25.254.250&apos;, 4002))
# 3.监听是否有客户端连接
server.listen(5)
print(&apos;服务端正在启动......&apos;)
# 4.接收客户端的连接，accept() -&gt; (socket object,address info)
clientSocket, address = server.accept()
print(&apos;客户端的地址：&apos;, address)
# 5.接收客户端发送的信息
recvData = clientSocket.recv(1024)
print(&quot;服务端接收的信息：&quot;, recvData.decode(&apos;utf-8&apos;))
# 6.给客户端回复消息，send（self,data:**bytes***,flags:int = .....）
clientSocket.send(&apos;你好，客户端&apos;.encode(&apos;utf-8&apos;))
# 7.关闭服务器端socket对象
server.close()</code></pre><p>代码实现客户端框架：</p>
<pre><code>import socket

# 1.创建一个socket对象；
# family指定使用IP协议的版本：IPV4：AF_INET; ipv6:AF_INET6
# type指定传输层使用的协议类型：TCP（SOCKET.SOCK_STREAM）,UDP(SOCK_DGRAM)
client = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
# 2.连接服务器(ip,port)
client.connect((&apos;172.25.254.250&apos;,4002))
# 3.给服务端回复消息，send（self，data：***bytes***，flages：int=...）-&gt; int:...
client.send(&apos;你好，服务器&apos;.encode(&apos;utf-8&apos;))

# 4.接收服务端回复的消息
recvData = client.recv(1024)
print(&apos;客户端接收的信息：&apos;, recvData.decode(&apos;utf-8&apos;))

# 5.关闭客户端socket对象
client.close()</code></pre><p><strong>应用：模拟QQ聊天</strong><br>代码实现（服务端）：</p>
<pre><code>import socket
# 1.创建对象
server = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
# 2.创建地址和端口
server.bind((&apos;172.25.254.49&apos;, 4002))
# 3.监听
server.listen(5)
print(&apos;服务端正在启动.....&apos;)
# 4.接收客户端的连接
ServerSocket, address = server.accept()
while True:
    # 5.接收客户端发送的消息
    recvData = ServerSocket.recv(1024)
    recv = recvData.decode(&apos;utf-8&apos;)
    print(&apos;服务端接收的信息：&apos;,recv )
    if recv == &apos;bye&apos;:
        break
    # 6.给客户端发送消息
    send_data = input(&quot;server:&gt;&gt;&quot;).encode(&apos;utf-8&apos;)
    ServerSocket.send(send_data)

# 7.关闭socket对象
server.close()
ServerSocket.close()</code></pre><p>客户端：</p>
<pre><code>import socket

# 1.创建一个socket对像；
client = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
# 2.连接服务端
client.connect((&apos;172.25.254.49&apos;, 4022))
# 3.给服务端发送信息
while True:
    send_data = input(&apos;client:&gt;&gt;&apos;).encode(&apos;utf-8&apos;)
    client.send(send_data)

    if send_data.decode(&apos;utf-8&apos;) == &apos;bye&apos;:
        break
# 5.关闭客户端socket对象
client.close()</code></pre><h2 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h2><p>并发服务器是socket应用编程中最常见的应用模型。根据连接方式分为长连接和短连接.<br><strong>长连接</strong>:建立SOCKET连接后不管是否使用都保持连接。<br><strong>短连接</strong>：双方都有数据交互时，建立TCP连接，数据发送完成后断开连接。</p>
<p><strong>并发服务器模型根据处理方式可分为同步方式和异步方式：</strong><br><img src="https://img-blog.csdnimg.cn/20190724120234663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>单进程服务器：</strong><br>同⼀时刻只能为⼀个客户进⾏服务，不能同时为多个客户服务<br>类似于找⼀个“明星”签字⼀样，客户需要耐⼼等待才可以获取到服务</p>
<p><strong>多进程服务器：</strong><br>优点: 通过为每个客户端创建⼀个进程的⽅式，能够同时为多个客户端进⾏服务<br>缺点: 当客户端不是特别多的时候，这种⽅式还⾏，如果有⼏百上千个，就不 可取了，因为每次创建进程等过程需要好较⼤的资源<br><img src="https://img-blog.csdnimg.cn/20190724120151352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190724120207344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码实现框架(服务端)：</p>
<pre><code>import socket
from multiprocessing import Process


def dealWithClient(ServerSocket, clientAddress):
    while True:
        # 5.接收客户端发送的消息
        recvData = ServerSocket.recv(1024)
        recv = recvData.decode(&apos;utf-8&apos;)
        print(clientAddress[0] + str(clientAddress[1]) + &apos;:&gt;&apos; + recv)
        if recv == &apos;quit&apos;:
            break
    ServerSocket.close()


# 1.创建对象
server = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
# 2.创建地址和端口
server.bind((&apos;172.25.254.49&apos;, 4022))
# 3.监听
server.listen(5)
print(&apos;服务端正在启动.....&apos;)
# 4.接收客户端的连接

while True:
    ServerSocket, address = server.accept()
    p = Process(target=dealWithClient, args=(ServerSocket, address))
    p.start()</code></pre><p><strong>多线程服务器</strong><br><img src="https://img-blog.csdnimg.cn/20190724134528139.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>gevent版-TCP服务器</strong><br><img src="https://img-blog.csdnimg.cn/2019072413461012.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190724134644809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/网络编程-Python实现/" data-id="cjyh27hw30003u65e2qk902y4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-多任务编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/多任务编程/" class="article-date">
  <time datetime="2019-07-24T09:33:39.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/多任务编程/">多任务编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="多任务编程"><a href="#多任务编程" class="headerlink" title="多任务编程"></a>多任务编程</h2><p>现实生活中的多任务：<br>有很多的场景中的事情是同时进行的，比如开车的时候，手和脚共同来驾驶汽车。再比如唱歌和跳舞也是同时进行的。</p>
<p><strong>什么叫”多任务”？</strong><br>就是操作系统可以同时运行多个人物。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有三个任务正在进行。还有很多任务悄悄的正在后台同时运行着，只是桌面上没有现实而已。</p>
<p><strong>单核CPU如何实现”多任务”呢？</strong><br>操作系统轮流让各个任务交替执行，每个任务执行0.01秒，这样反复执行下去。表面上看，每个任务交替执行，但CPU的执行速度实在是太快了，感觉就像所有任务都在同时执行一样。<br><img src="https://img-blog.csdnimg.cn/20190722101341379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>多核CPU如何实现”多任务”呢?</strong></p>
<p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多与CPU的核心数量，所以操作系统也会自动把很多任务轮流调度到每个核心上执行。<br><img src="https://img-blog.csdnimg.cn/20190722105118297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>编写完毕的代码，在没有运行的时候，称之为<strong>程序</strong>。<br>正在运行着的代码，就成为<strong>进程</strong>。<br><strong>注意</strong>：进程，除了包含代码以外，还需要运行的环境等，所以和程序是由区别的</p>
<p><img src="https://img-blog.csdnimg.cn/20190722110156741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>创建子进程</strong><br>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：<br><img src="https://img-blog.csdnimg.cn/20190722110410416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Python中创建子进程的常用函数：</p>
<pre><code>&quot;&quot;&quot;
os.fork()
os.getpid()   #获取当前进程的pid (process id)
os.getppid()    #获取当前进程的父进程pid(parent process id)
&quot;&quot;&quot;
import os
print(&quot;当前进程(pid = %d)正在运行......&quot; %(os.getpid()))
#在pycharm编写代码，程序的父进程就是pycharm；
print(&quot;当前进程的父进程为(pid=%d)正在运行.....&quot; %(os.getppid()))
print(&quot;开始创建子进程.....&quot;)

pid = os.fork()
if pid == 0;
    print(&apos;这是子进程返回的是0，子进程的pid为%d,父进程为%d&apos; %(os.getpid(),os.getppid()))
else:
    pring(&quot;这是父进程返回的，返回值为子进程的pid，为%d&quot; %(pid))</code></pre><p><strong>fork函数的作用：</strong><br>1.执行到os.fork()时，操作系统会创建一个新的进程复制父进程的所有信息到子进程中。<br>2.普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次。<br>3.父进程和子进程都会从fork()函数中得到一个返回值，子进程返回的是0，而父进程中返回子进程的id号。</p>
<p><strong>多进程修改全局变量</strong><br>多进程中，每个进程中所有数据(包括全局变量)都各拥有一份，互不影响。</p>
<p>由于Windows没有fork调用，由于Python是跨平台的，multiprocessing模块就是跨平台版本的多进程模块。multiprocessing模块提供了一个Processing模块提供了一个Process类来代表一个进程对象。</p>
<p>Process([group [, target [, name [, args [, kwargs]]]]])<br>    target：表示这个进程实例所调⽤对象；<br>    args：表示调⽤对象的位置参数元组；<br>    kwargs：表示调⽤对象的关键字参数字典；<br>    name：为当前进程实例的别名；<br>    group：⼤多数情况下⽤不到；<br>    Process类常⽤⽅法：<br>    is_alive()：    判断进程实例是否还在执⾏；<br>    join([timeout])：    是否等待进程实例执⾏结束，或等待多少秒；<br>    start()：        启动进程实例（创建⼦进程）；<br>    run()：        如果没有给定target参数，对这个对象调⽤start()⽅法时，就将执 ⾏对象中的run()⽅法；<br>    terminate()：    不管任务是否完成，⽴即终⽌；</p>
<p><strong>Process类常⽤属性</strong>：<br>    name：当前进程实例别名，默认Process-N，N为从1开始计数；<br>    pid：当前进程实例的PID值；</p>
<p><strong>多进程编程方法一：实例化对象</strong></p>
<pre><code>from multiprocessing import Process
for i in range(len(expression_list)):
    p = Process(target=eval_formula,args=(expression_list[i],))
    p.start()
    p.join()
def eval_formula(formula):</code></pre><p>示例1：</p>
<pre><code>from multiprocessing import Process
import time
def task1(): #定义第一个任务
    print(&apos;正在听音乐&apos;)
    time.sleep(1) #运行过后休眠1s
def task2(): #定义第二个任务
    print(&apos;正在编程。。。。&apos;)
    time.sleep(0.5) #运行完成休眠0.5s
def no_multi(): #不使用多进程编程运行的方法
    for i in range(2):
        task1()
    for i in range(5):
        task2()
def use_multi(): #使用多进程编程使程序运行
    processes = [] #创建一个列表，将运行次每次任务的过程存入列表
    for i in range(2):
        p = Process(target=task1,)
        p.start()
        processes.append(p)
    for i in range(5):
        p = Process(target=task2)
        p.start()
        processes.append(p)
    [process.join() for process in processes] #使前两个函数任务阻塞，运行完后方可运行主函数(当需要计算函数运行时间的时候需要用)
if __name__ == &apos;__main__&apos;:
    start_time = time.time()
    use_multi() #调用多进程方法，查看多进程运行所需时间
    end_time = time.time()
print(end_time-start_time)</code></pre><p><img src="https://img-blog.csdnimg.cn/201907221159147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以上为多进程编程运行所需要的时间，如果单进程的话时间应该为2<em>1+5</em>0.5=4.5s</p>
<p><strong>多进程编程方法2</strong></p>
<p>改写run函数：</p>
<p><img src="https://img-blog.csdnimg.cn/20190722134319851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><p><strong>为什么需要进程池Pool？</strong><br>当被操作对象数目不大时，可以直接利用multiprocessing中的Process动态成生多个进程，十几个还好，但如果是上百个，上千个目标，手动的去限制进程数量却又太过繁琐，此时可以发挥进程池的功效。</p>
<p>Pool可以提供指定数量的进程供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来它。</p>
<p><strong>进程池实现1：</strong></p>
<pre><code>import multiprocessing
p = multiprocessing.Pool(multiprocessing.cpu_count())
result = p.map(ecal_formula,expression_list)
p.close()
p.join()

def eval_formual(formula):
    #evalueates the expression</code></pre><p><strong>进程池实现2：</strong></p>
<pre><code>import multiprocessing
def job(id):

    print(&quot;start %d....&quot; % (id))

    print(&quot;end %d....&quot; % (id))
# 创建进程池对象
pool = multiprocessing.Pool(processes=4)
# 给进程池分配任务;
for i in range(10):
    pool.apply_async(job, args=(i + 1,))
pool.close()
# 等待所有的子进程执行结束， 关闭进程池对象;
pool.join()
print(&quot;所有任务执行结束.....&quot;)</code></pre><p><strong>进程池实现3：</strong></p>
<pre><code>from concurrent.futures import ProcessPoolExecutor
def job(id):
    print(&apos;start %d...&apos; % (id)&apos;)
    print(&quot;end %d...&quot; % (id))
pool = ProcessPoolExecutor(max_workers = 4)
#
#for id in ranger(10):
#    #分配任务给子进程，并且返回一个Future对象；
#         f1 = pool.submit(job,args=(id))
#     #判断子进程是否执行结束
#        print(f1.done())
#    #查看该子进程执行的结果
#        print(f1,range(10))</code></pre><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><strong>为什么需要进程之间的通信？</strong><br><img src="https://img-blog.csdnimg.cn/20190722141727156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>如何实现进程间的通信？</strong><br><img src="https://img-blog.csdnimg.cn/20190722141959367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>消息队列</strong><br>可以使⽤multiprocessing模块的Queue实现多进程之间的数据传递，<strong>Queue 本身是⼀个消息列队程序。</strong><br>Queue.qsize()：    返回当前队列包含的消息数量；<br>Queue.empty()：    如果队列为空，返回True，反之False ；<br>Queue.full()：    如果队列满了，返回True,反之False；<br>Queue.get([block[, timeout]])：<br>    获取队列中的⼀条消息，然后将其从列队中移除，block默认值为True；<br>Queue.get_nowait()：<br>    相当Queue.get(False)；<br>Queue.put(item,[block[, timeout]])：<br>    将item消息写⼊队列，block默认值 为True；<br>Queue.put_nowait(item)：<br>    相当Queue.put(item, False)</p>
<p><strong>消息队列实例：</strong></p>
<pre><code>import time</code></pre><p>import multiprocessing</p>
<p>class Producer(multiprocessing.Process):<br>    def <strong>init</strong>(self, queue):<br>        super(Producer, self).<strong>init</strong>()<br>        self.queue = queue</p>
<pre><code>def run(self):
    for i in range(10):
        self.queue.put(i)
        time.sleep(0.1)
        print(&apos;传递信息，内容为%s&apos; % (i))


class Consumer(multiprocessing.Process):
    def __init__(self, queue):
        super(Consumer, self).__init__()
        self.queue = queue

def run(self):
    while True:
        time.sleep(0.1)
        recvData = self.queue.get()
        print(&apos;接受到另一进程传递的数据：%s&apos; % (recvData))
if __name__ == &apos;__main__&apos;:
    q = multiprocessing.Queue()
    p1 = Producer(q)
    c1 = Consumer(q)

    p1.start()
    c1.start()
    p1.join()
    c1.join()</code></pre><p>输出结果与队列相似，先传入的先传出，后传入的后传出。</p>
<h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。<br><img src="https://img-blog.csdnimg.cn/20190722145312246.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>每个进程至少有一个线程，即进程本身。进程可以启动多个线程。操作系统像并行“进程”一样执行这些线程。<br><img src="https://img-blog.csdnimg.cn/20190722145435412.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>线程和进程各自有什么区别和优劣呢？</strong><br>进程是资源分配的最小单位，线程是程序执行的最小单位。<br>进程有自己的独立地址空间。线程是共享进程中的数据的，使用相同的地址空间.<br>进程之间的通信需要以通信的方式（IPC)进行。线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，难点:处理好同步与互斥。</p>
<p><strong>线程分类</strong><br>有两种不同的线程：<br>内核线程<br>用户空间线程或用户线程<br>内核线程是操作系统的一部分，而内核中没有实现用户空间线程。</p>
<p><strong>多线程编程实现</strong><br>python的thread模块是⽐较底层的模块，python的threading 模块是对thread做了⼀些包装的，可以更加⽅便的被使⽤<br><img src="https://img-blog.csdnimg.cn/20190722145743512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>方法分析</strong><br>多线程程序的执⾏顺序是不确定的。<br>当执⾏到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进⼊就绪（Runnable）状态，等待调度。⽽线程调度将⾃⾏选择⼀个线程执⾏。<br>代码中只能保证每个线程都运⾏完整个run函数，但是线程的启动顺序、 run函数中每次循环的执⾏顺序都不能确定。</p>
<p><img src="https://img-blog.csdnimg.cn/20190722145910769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="项目案例-IP地址归属地批量查询任务"><a href="#项目案例-IP地址归属地批量查询任务" class="headerlink" title="项目案例: IP地址归属地批量查询任务"></a>项目案例: IP地址归属地批量查询任务</h2><p><strong>地址处于活动状态或哪些计算机处于活动状态，则可以使用此脚本。我们将依次ping地址, 每次都要等几秒钟才能返回值。这可以在Python中编程，在IP地址的地址范围内有一个for循环和一个os.popen（“ping -q -c2”+ ip）。</strong> </p>
<p><strong>项目瓶颈: 没有线程的解决方案效率非常低，因为脚本必须等待每次ping。</strong> </p>
<p>非多线程版本代码：</p>
<pre><code>import json
import requests
import pymysql

conn = pymysql.connect(host=&apos;172.25.254.149&apos;, user=&apos;root&apos;, password=&apos;990038&apos;, db=&apos;mysql&apos;)
#连接数据库
cursor = conn.cursor()
#设置邮标
# create_sqli = &apos;create table IP(ipid varchar(20),ipcity varchar(20),ipcountry varchar(20));&apos;(数据库建表操作，如果已经存在这一步便没有必要重复进行)
# cursor.execute(create_sqli)


def get_addr(ip):
    url = &apos;http://ip-api.com/json/%s&apos; % (ip)
    #从上面这个网址获取各ip所在地址
    count = requests.get(url).text
    dict_data = json.loads(count)
    city = dict_data.get(&apos;city&apos;)
    country = dict_data.get(&apos;country&apos;)
    #获取到所在城市以及国家的信息
    insert_sqli = &apos;insert into IP(ipid,ipcity,ipcountry) values(&quot;%s&quot;, &quot;%s&quot;, &quot;%s&quot;);&apos; %(ip, city, country)
    #将获取到的信息导入数据库
    print(insert_sqli)
    #将结果打印出来确定是否导入
    cursor.execute(insert_sqli)
    conn.commit()
    # print(&quot;&quot;&quot;
    # %s
    # 所在城市：%s
    # 所在国家：%s
    #
    # &quot;&quot;&quot; % (ip,dict_data[&apos;city&apos;],dict_data[&apos;country&apos;]))


if __name__ == &apos;__main__&apos;:
    for i in range(25):
        ip = str(&apos;1.1.1.&apos;) + str(1 + i)
        get_addr(ip)
        #将1.1.1.1到1.1.1.255的ip信息全部获取并且存入
    cursor.close()
    conn.close()</code></pre><p>多线程版本代码(使用sqlalchemy)：</p>
<pre><code>import requests
import json
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from threading import Thread


def task(ip):
    &quot;&quot;&quot;获取指定IP的所在城市和国家并存储到数据库中&quot;&quot;&quot;
    # 获取网址的返回内容
    url = &apos;http://ip-api.com/json/%s&apos; % (ip)
    try:
        response = requests.get(url)
    except Exception as e:
        print(&quot;网页获取错误:&quot;, e)
    else:
        # 默认返回的是字符串
        &quot;&quot;&quot;
        {&quot;as&quot;:&quot;AS174 Cogent Communications&quot;,&quot;city&quot;:&quot;Beijing&quot;,&quot;country&quot;:&quot;China&quot;,&quot;countryCode&quot;:&quot;CN&quot;,&quot;isp&quot;:&quot;China Unicom Shandong Province network&quot;,&quot;lat&quot;:39.9042,&quot;lon&quot;:116.407,&quot;org&quot;:&quot;NanJing XinFeng Information Technologies, Inc.&quot;,&quot;query&quot;:&quot;114.114.114.114&quot;,&quot;region&quot;:&quot;BJ&quot;,&quot;regionName&quot;:&quot;Beijing&quot;,&quot;status&quot;:&quot;success&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;zip&quot;:&quot;&quot;}
        &quot;&quot;&quot;
        contentPage = response.text
        # 将页面的json字符串转换成便于处理的字典;
        data_dict = json.loads(contentPage)
        # 获取对应的城市和国家
        city = data_dict.get(&apos;city&apos;, &apos;null&apos;)  # None
        country = data_dict.get(&apos;country&apos;, &apos;null&apos;)

        print(ip, city, country)
        # 存储到数据库表中ips
        ipObj = IP(ip=ip, city=city, country=country)
        session.add(ipObj)
        session.commit()


if __name__ == &apos;__main__&apos;:
    engine = create_engine(&quot;mysql+pymysql://root:westos@172.25.254.123/pymysql&quot;,
                           encoding=&apos;utf8&apos;,
                           # echo=True
                           )
    # 创建缓存对象
    Session = sessionmaker(bind=engine)
    session = Session()

# 声明基类
Base = declarative_base()


class IP(Base):
    __tablename__ = &apos;ips&apos;
    id = Column(Integer, primary_key=True, autoincrement=True)
    ip = Column(String(20), nullable=False)
    city = Column(String(30))
    country = Column(String(30))

    def __repr__(self):
        return self.ip


# 创建数据表
Base.metadata.create_all(engine)

# 1.1.1.1 -- 1.1.1.10
threads = []
for item in range(10):
    ip = &apos;1.1.1.&apos; + str(item + 1)  # 1.1.1.1 -1.1.1.10
    # task(ip)
    # 多线程执行任务
    thread = Thread(target=task, args=(ip,))
    # 启动线程并执行任务
    thread.start()
    # 存储创建的所有线程对象;
    threads.append(thread)

[thread.join() for thread in threads]
print(&quot;任务执行结束.........&quot;)
print(session.query(IP).all())</code></pre><p><strong>共享全局变量</strong><br>优点: 在⼀个进程内的所有线程共享全局变量，能够在不使⽤其他⽅式的前提 下完成多线程之间的数据共享（这点要⽐多进程要好） </p>
<p>缺点: 线程是对全局变量随意遂改可能造成多线程之间对全局变量 的混乱（即线程⾮安全）</p>
<p><strong>享全局变量：如何解决线程不安全问题?</strong><br>GIL(global interpreter lock): python解释器中任意时刻都只有一个线程在执行;<br>Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。</p>
<p><img src="https://img-blog.csdnimg.cn/20190722152428455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190722152459624.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>线程同步：</strong><br>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作.<br><strong>同步就是协同步调，按预定的先后次序进⾏运⾏。如:你说完，我再说。 “同”字从字⾯上容易理解为⼀起动作 其实不是，”同”字应是指协同、协助、互相配合。</strong></p>
<p><strong>线程锁的代码实现。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190722153157151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>银行转账问题：</strong></p>
<pre><code>import threading


def add(lock):
    global money #声明money为全局变量
    for i in range(1000000):
        #2.操作变量之前进行加锁
        lock.acquire()
        money += 1
        lock.release()

def reduce(lock):
    global money
    for i in range(100000):
        #2.操作变量之前进行加锁
        lock.acquire()
        money -= 1
        #3.操作变量之后进行解锁
        lock.release()
if __name__ == &apos;__main__&apos;:
    money = 0
    #1.实例化一个锁对象
    lock = threading.Lock()
    t1 = threading.Thread(target=add,args=(lock,))
    t2 = threading.Thread(target=reduce,args=(lock,))
    t1.start()
    t2.start()
    t1.join()
    t2.join()
    print(&apos;当前金额：&apos;,money)</code></pre><p><strong>死锁</strong><br>在线程间共享多个资源的时候，如果两个线程分别占有⼀部分资源并且同时 等待对⽅的资源，就会造成死锁。<br><img src="https://img-blog.csdnimg.cn/20190722154356995.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190722154420130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>协程，又称微线程，纤程。英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</strong><br><img src="https://img-blog.csdnimg.cn/20190722154527346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>协程优势</strong><br>    执行效率极高,因为子程序切换(函数)不是线程切换,由程序自身控制,<br>    没有切换线程的开销。所以与多线程相比,线程的数量越多,协程性能的优势越明显。<br>    不需要多线程的锁机制,因为只有一个线程,也不存在同时写变量冲突,在控制共享资源时也不需要加锁,因此执行效率高很多。</p>
<p><strong>实现协程的方法一（yield方法）：</strong><br><img src="https://img-blog.csdnimg.cn/2019072215475599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190722154819919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>基本思想：<br>当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。<br><img src="https://img-blog.csdnimg.cn/20190722155133261.png" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img-blog.csdnimg.cn/20190722155226232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE4NzY2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>线程与进程的区别？<br>答：进程为正在运行着的代码，除此之外还有需要运行的环境等。线程是操作系统能够运行的最小单位，他被包含在进程之中是进程中的实际运作单位。</li>
<li>进程间内存是否共享？如何实现通讯？<br>答：可以共享，可以通过进程池以及消息队列的方式进行内存分配。通过消息队列进行通讯，目的为数据传输，共享数据，通知事件，资源共享以及进程控制</li>
<li>进程间通信的方式？<br>答：linux系统进程间的通信方式有管道，信号，消息队列，以及套间字</li>
<li>多线程有几种实现方法，都是什么？<br>答：分别是实例化对象方法，以及创建子类方法。</li>
<li>GIL锁是怎么回事?<br>答：当存在全局变量时，每一个线程都要对全局变量进行修改改或者更新时，就还出现错误，所以python中就设置有GIL锁，使得在修改全局变量时只能一个线程能对其进行操作，当一个线程运行完后，下一个线程才能对其进行操作。</li>
<li>python中是否线程安全？如何解决线程安全？<br>答：Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。</li>
<li>什么叫死锁？<br>答：在线程间共享多个资源的时候，如果两个线程分别占有⼀部分资源并且同时 等待对⽅的资源，就会造成死锁。</li>
<li>什么是协程？常用的协程模块有哪些？</li>
<li>协程中的join是用来做什么用的？它是如何发挥作用的？</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/多任务编程/" data-id="cjyh27hw00002u65e98ft22hj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-aa" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/aa/" class="article-date">
  <time datetime="2019-07-24T09:26:59.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/aa/">aa</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>aa</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/aa/" data-id="cjyh27hvk0000u65epx2ha5de" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/hello-world/" class="article-date">
  <time datetime="2019-07-24T08:43:00.635Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/hello-world/" data-id="cjyh27hvw0001u65esh57v1vz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/24/网络编程-Python实现/">网络编程(Python实现)</a>
          </li>
        
          <li>
            <a href="/2019/07/24/多任务编程/">多任务编程</a>
          </li>
        
          <li>
            <a href="/2019/07/24/aa/">aa</a>
          </li>
        
          <li>
            <a href="/2019/07/24/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 赵子乔<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>